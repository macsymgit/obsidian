/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/services/adapters/cloudEndpoints.json
var require_cloudEndpoints = __commonJS({
  "src/services/adapters/cloudEndpoints.json"(exports, module2) {
    module2.exports = {
      openai: "https://api.openai.com/v1/chat/completions",
      gemini: "https://generativelanguage.googleapis.com/v1beta/openai/chat/completions",
      deepseek: "https://api.deepseek.com/v1/chat/completions",
      aliyun: "https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions",
      claude: "https://api.anthropic.com/v1/complete",
      groq: "https://api.groq.com/openai/v1/chat/completions",
      openrouter: "https://openrouter.ai/api/v1/chat/completions",
      bedrock: "https://bedrock-runtime.amazonaws.com",
      requesty: "https://api.requesty.ai/v1/chat/completions",
      cohere: "https://api.cohere.ai/v1/generate",
      grok: "https://api.grok.x.ai/v1/chat/completions",
      mistral: "https://api.mistral.ai/v1/generate",
      vertex: "https://us-central1-aiplatform.googleapis.com/v1/projects/{project}/locations/{location}/endpoints/{endpoint}:predict",
      "openai-compatible": "http://your-api-endpoint/v1/chat/completions"
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AITaggerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/utils/languageUtils.ts
var LanguageUtils = class {
  /**
   * Get the display name for a language code
   * @param code - Language code
   * @returns Language display name
   */
  static getLanguageDisplayName(code) {
    if (!code || code === "default") {
      return "Default";
    }
    return this.LANGUAGE_NAMES[code] || code;
  }
  /**
   * Get all supported language codes and their display names
   * @returns Map of language codes to display names
   */
  static getLanguageOptions() {
    return { ...this.LANGUAGE_NAMES };
  }
};
/**
 * Maps language codes to their proper display names
 */
__publicField(LanguageUtils, "LANGUAGE_NAMES", {
  "default": "Default",
  "ar": "Arabic",
  "cs": "Czech",
  "da": "Danish",
  "de": "German",
  "en": "English",
  "es": "Spanish",
  "fr": "French",
  "id": "Indonesian",
  "it": "Italian",
  "ja": "Japanese",
  "ko": "Korean",
  "nl": "Dutch",
  "no": "Norwegian",
  "pl": "Polish",
  "pt": "Portuguese",
  "pt-BR": "Brazilian Portuguese",
  "ro": "Romanian",
  "ru": "Russian",
  "tr": "Turkish",
  "uk": "Ukrainian",
  "zh": "Chinese (Simplified)",
  "zh-TW": "Chinese (Traditional)"
});

// src/services/prompts/tagPrompts.ts
function buildTagPrompt(content, candidateTags, mode, maxTags = 5, language) {
  let prompt = "";
  let langInstructions = "";
  if (language && language !== "default") {
    const languageName = LanguageUtils.getLanguageDisplayName(language);
    switch (mode) {
      case "hybrid" /* Hybrid */:
        langInstructions = `IMPORTANT: Generate all new tags in ${languageName} language only.
When generating new tags (not selecting from predefined ones), they must be in ${languageName} only.

`;
        break;
      case "generate" /* GenerateNew */:
        langInstructions = `IMPORTANT: Generate all tags in ${languageName} language only.
Regardless of what language the content is in, all tags must be in ${languageName} only.
First understand the content, then if needed translate concepts to ${languageName}, then generate tags in ${languageName}.

`;
        break;
      default:
        langInstructions = "";
    }
  }
  switch (mode) {
    case "predefined" /* PredefinedTags */:
      prompt += `Analyze the following content and select up to ${maxTags} most relevant tags from the provided tag list.
Only use exact matches from the provided tags, do not modify or generate new tags.

Available tags:
${candidateTags.join(", ")}

Content:
${content}

Return only the selected tags as a comma-separated list without # symbol:
hello, world, ,hello-world`;
      break;
    case "hybrid" /* Hybrid */:
      prompt += `${langInstructions}Analyze the following content and:
1. Select relevant tags from the provided tag list (up to ${Math.ceil(maxTags / 2)} tags)
2. Generate additional new tags not in the list (up to ${Math.ceil(maxTags / 2)} tags)

Available tags to select from:
${candidateTags.join(", ")}

Content:
${content}

Return your response in this JSON format:
{
  "matchedExistingTags": ["tag1", "tag2"], 
  "suggestedTags": ["new-tag1", "new-tag2"]
}
note: don't add "matchedExistingTags" or "suggestedTags" to the tags themselves - only use each once as a json key to provide a valid response strictly following the schema above. 

Do not include the # symbol in tags.`;
      break;
    case "generate" /* GenerateNew */:
      prompt += `${langInstructions}Analyze the following content and generate up to ${maxTags} relevant tags.
Return tags without the # symbol.

Content:
${content}

Return the tags as a comma-separated list:
hello, world, hello world,hello-world`;
      break;
    default:
      throw new Error(`Unsupported tagging mode: ${mode}`);
  }
  return prompt;
}

// src/utils/constants.ts
var SYSTEM_PROMPT = 'You are a professional document tag analysis assistant. Please return your response as a plain text string of comma-separated tags. For example: "hello, world, hello world, hello-world"';
var TAG_RANGE = {
  MIN: 0,
  MAX: 10
};
var TAG_PREDEFINED_RANGE = {
  MIN: TAG_RANGE.MIN,
  MAX: 5
};
var TAG_GENERATE_RANGE = {
  MIN: TAG_RANGE.MIN,
  MAX: 5
};

// src/services/baseService.ts
var BaseLLMService = class {
  endpoint;
  modelName;
  TIMEOUT = 3e4;
  // 30 seconds timeout
  activeRequests = /* @__PURE__ */ new Set();
  app;
  /**
   * Creates a new LLM service instance
   * @param config - Configuration for the LLM service
   */
  constructor(config, app) {
    this.endpoint = config.endpoint.trim();
    this.modelName = config.modelName.trim();
    this.app = app;
  }
  /**
   * Formats a request for the LLM service
   * This serves as a default implementation. Specific service adapters should override as needed.
   * @param prompt - The prompt to send to the LLM
   * @param language - Optional language code
   * @returns Formatted request body
   */
  formatRequest(prompt, language) {
    return {
      model: this.modelName,
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: prompt }
      ],
      temperature: 0.3
    };
  }
  /**
   * Registers an active request for cleanup
   * @param controller - AbortController for the request
   * @param timeoutId - Optional timeout ID
   * @returns Cleanup function
   */
  registerRequest(controller, timeoutId) {
    const request = { controller, timeoutId };
    this.activeRequests.add(request);
    return () => {
      if (request.timeoutId) {
        clearTimeout(request.timeoutId);
      }
      this.activeRequests.delete(request);
    };
  }
  /**
   * Creates an AbortController with timeout for a request
   * @param timeoutMs - Timeout in milliseconds
   * @returns Controller and cleanup function
   */
  createRequestController(timeoutMs) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort(new Error("Request timeout"));
    }, timeoutMs);
    const cleanup = this.registerRequest(controller, timeoutId);
    return { controller, cleanup };
  }
  /**
   * Cleans up all active requests
   * Should be called when the service is no longer needed
   */
  async dispose() {
    this.activeRequests.forEach((request) => {
      if (request.timeoutId) {
        clearTimeout(request.timeoutId);
      }
      request.controller.abort(new Error("Service disposed"));
    });
    this.activeRequests.clear();
  }
  /**
   * Validates the service configuration
   * @returns Error message if invalid, null if valid
   */
  validateConfig() {
    if (!this.endpoint) {
      return "API endpoint is not configured";
    }
    if (!this.modelName) {
      return "Model name is not configured";
    }
    try {
      new URL(this.endpoint);
    } catch {
      return "Invalid API endpoint URL format";
    }
    return null;
  }
  /**
   * Extracts JSON content from an LLM response
   * @param response - Raw response from LLM
   * @param retryCount - Number of retries attempted
   * @returns Extracted JSON string
   * @throws Error if no valid JSON found
   */
  extractJSONFromResponse(response, retryCount = 0) {
    const markdownJsonRegex = /```(?:json)?\s*(\{[\s\S]*?\})\s*```/;
    const markdownMatch = response.match(markdownJsonRegex);
    if (markdownMatch) {
      try {
        JSON.parse(markdownMatch[1]);
        return markdownMatch[1];
      } catch {
      }
    }
    const jsonRegex = /\{[\s\S]*\}/;
    const jsonMatch = response.match(jsonRegex);
    if (jsonMatch) {
      try {
        JSON.parse(jsonMatch[0]);
        return jsonMatch[0];
      } catch {
      }
    }
    if (retryCount === 0) {
      return this.extractJSONFromResponse(response.replace(/\n/g, " "), 1);
    } else if (retryCount === 1) {
      const tags = /* @__PURE__ */ new Set();
      const hashtagRegex = /#[\p{Letter}\p{Number}-]+/gu;
      const hashtags = response.match(hashtagRegex);
      if (hashtags) {
        hashtags.forEach((tag) => {
          tags.add(tag);
        });
      }
      const potentialTagsRegex = /["']([a-zA-Z0-9-]+)["']/g;
      let match;
      while ((match = potentialTagsRegex.exec(response)) !== null) {
        const tag = `#${match[1]}`;
        tags.add(tag);
      }
      if (tags.size > 0) {
        return JSON.stringify({
          matchedTags: [],
          newTags: Array.from(tags)
        });
      }
    }
    throw new Error("No valid JSON or tags found in response");
  }
  /**
   * Builds a prompt for tag analysis based on the specified mode
   * @param content - Content to analyze
   * @param candidateTags - Array of candidate tags
   * @param mode - Tagging mode
   * @param maxTags - Maximum number of tags to return
   * @param language - Language code for generated tags
   * @returns Formatted prompt string
   */
  buildPrompt(content, candidateTags, mode, maxTags, language) {
    return buildTagPrompt(content, candidateTags, mode, maxTags, language);
  }
  /**
   * Parses and validates LLM response
   * @param response - Raw response from LLM
   * @param mode - Tagging mode
   * @param maxTags - Maximum number of tags to return
   * @returns Parsed and validated response
   * @throws Error if response is invalid
   */
  parseResponse(response, mode, maxTags) {
    try {
      try {
        const jsonResponse = JSON.parse(response.trim());
        if (mode === "hybrid" /* Hybrid */) {
          if (Array.isArray(jsonResponse.matchedExistingTags) && Array.isArray(jsonResponse.suggestedTags)) {
            return {
              matchedExistingTags: jsonResponse.matchedExistingTags.slice(0, maxTags),
              suggestedTags: jsonResponse.suggestedTags.slice(0, maxTags)
            };
          }
          if (Array.isArray(jsonResponse.matchedTags) && Array.isArray(jsonResponse.newTags)) {
            return {
              matchedExistingTags: jsonResponse.matchedTags.slice(0, maxTags),
              suggestedTags: jsonResponse.newTags.slice(0, maxTags)
            };
          }
          if (Array.isArray(jsonResponse.tags)) {
            const processedTags = this.processTagsFromResponse(jsonResponse);
            return {
              matchedExistingTags: [],
              suggestedTags: processedTags.tags.slice(0, maxTags)
            };
          }
        }
        if (Array.isArray(jsonResponse.tags)) {
          const processedTags = this.processTagsFromResponse(jsonResponse);
          switch (mode) {
            case "predefined" /* PredefinedTags */:
              return {
                matchedExistingTags: processedTags.tags.slice(0, maxTags),
                suggestedTags: []
              };
            case "generate" /* GenerateNew */:
            default:
              return {
                matchedExistingTags: [],
                suggestedTags: processedTags.tags.slice(0, maxTags)
              };
          }
        }
        if (Array.isArray(jsonResponse.matchedTags) && mode === "predefined" /* PredefinedTags */) {
          return {
            matchedExistingTags: jsonResponse.matchedTags.slice(0, maxTags),
            suggestedTags: []
          };
        }
        if (Array.isArray(jsonResponse.newTags) && mode === "generate" /* GenerateNew */) {
          return {
            matchedExistingTags: [],
            suggestedTags: jsonResponse.newTags.slice(0, maxTags)
          };
        }
      } catch (e) {
      }
      let cleanedResponse = response.replace(/^```.*$/gm, "").replace(/^\s*[\-\*]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").trim();
      const processedResponse = this.processTagsFromResponse(cleanedResponse);
      switch (mode) {
        case "predefined" /* PredefinedTags */:
          return {
            matchedExistingTags: processedResponse.tags.slice(0, maxTags),
            suggestedTags: []
          };
        case "hybrid" /* Hybrid */:
          return {
            matchedExistingTags: [],
            suggestedTags: processedResponse.tags.slice(0, maxTags)
          };
        case "generate" /* GenerateNew */:
        default:
          return {
            matchedExistingTags: [],
            suggestedTags: processedResponse.tags.slice(0, maxTags)
          };
      }
    } catch (error) {
      throw new Error(`Invalid response format: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Process raw response content to extract tags
   * @param content - Raw content to process (string or object)
   * @returns Object with tags array
   */
  processTagsFromResponse(content) {
    try {
      if (!content) {
        return { tags: [] };
      }
      let textContent = "";
      if (typeof content === "string") {
        textContent = content;
      } else if (Array.isArray(content)) {
        textContent = content.filter((item) => item !== null && item !== void 0).join(", ");
      } else if (typeof content === "object" && content !== null) {
        const candidateFields = ["tags", "tag", "matchedExistingTags", "suggestedTags", "matchedTags", "newTags", "content", "results"];
        for (const field of candidateFields) {
          if (Array.isArray(content[field])) {
            textContent = content[field].filter((tag) => tag !== null && tag !== void 0).join(", ");
            break;
          } else if (typeof content[field] === "string" && content[field].trim()) {
            textContent = content[field].trim();
            break;
          }
        }
        if (!textContent) {
          for (const [key, value] of Object.entries(content)) {
            if (typeof value === "string" && value.trim()) {
              textContent = value.trim();
              break;
            } else if (Array.isArray(value) && value.length > 0) {
              textContent = value.filter((item) => item !== null && item !== void 0).join(", ");
              break;
            }
          }
        }
      }
      if (!textContent.trim()) {
        return { tags: [] };
      }
      let tags = [];
      if (textContent.trim().startsWith("{") || textContent.trim().startsWith("[")) {
        try {
          const jsonContent = JSON.parse(textContent);
          if (Array.isArray(jsonContent)) {
            tags = jsonContent.map((item) => typeof item === "string" ? item.trim() : String(item).trim()).filter((tag) => tag.length > 0);
          } else if (typeof jsonContent === "object" && jsonContent !== null && Array.isArray(jsonContent.tags)) {
            tags = jsonContent.tags.map((tag) => typeof tag === "string" ? tag.trim() : String(tag).trim()).filter((tag) => tag.length > 0);
          }
        } catch (jsonError) {
        }
      }
      if (tags.length === 0) {
        if (textContent.includes(",")) {
          tags = textContent.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
        } else {
          tags = textContent.split(/[\n\r]+/).map((line) => line.trim()).filter((line) => line.length > 0);
          if (tags.some((line) => line.length > 30 || line.includes("."))) {
            const potentialTags = [];
            for (const line of tags) {
              if (line.includes(",")) {
                const parts = line.split(",").map((part) => part.trim()).filter((part) => part.length > 0 && part.length < 30);
                potentialTags.push(...parts);
              } else if (line.length < 30) {
                potentialTags.push(line);
              }
            }
            if (potentialTags.length > 0) {
              tags = potentialTags;
            }
          }
        }
      }
      const uniqueTags = [...new Set(tags.map((tag) => tag.toString().trim()))].filter((tag) => tag.length > 0);
      return { tags: uniqueTags };
    } catch (error) {
      return { tags: [] };
    }
  }
  /**
   * Handles errors consistently across the service
   * @param error - Error to handle
   * @param operation - Operation that failed
   * @throws Error with consistent format
   */
  handleError(error, operation) {
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        throw new Error(`Operation timed out: ${operation}`);
      }
      throw new Error(`${operation} failed: ${error.message}`);
    }
    throw new Error(`${operation} failed with unknown error`);
  }
  /**
   * Analyzes content and generates tags
   * Template method implementation that handles common logic
   * @param content - Content to analyze
   * @param candidateTags - Array of candidate tags
   * @param mode - Tagging mode
   * @param maxTags - Maximum number of tags to return
   * @param language - Language code for tag generation
   * @returns Promise resolving to tag analysis result
   */
  async analyzeTags(content, candidateTags, mode = "generate" /* GenerateNew */, maxTags = 10, language) {
    try {
      if (!content.trim()) {
        throw new Error("Empty content provided for analysis");
      }
      const maxContentLength = this.getMaxContentLength();
      if (content.length > maxContentLength) {
        content = content.slice(0, maxContentLength) + "...";
      }
      let prompt;
      switch (mode) {
        case "generate" /* GenerateNew */:
          prompt = this.buildPrompt(content, [], mode, maxTags, language);
          break;
        case "predefined" /* PredefinedTags */:
          if (!candidateTags || candidateTags.length === 0) {
            throw new Error("Predefined tags mode requires candidate tags");
          }
          prompt = this.buildPrompt(content, candidateTags, mode, maxTags, language);
          break;
        case "hybrid" /* Hybrid */:
          if (!candidateTags || candidateTags.length === 0) {
            prompt = this.buildPrompt(content, [], "generate" /* GenerateNew */, maxTags, language);
          } else {
            prompt = this.buildPrompt(content, candidateTags, mode, maxTags, language);
          }
          break;
        default:
          prompt = this.buildPrompt(content, candidateTags, mode, maxTags, language);
      }
      if (!prompt.trim()) {
        throw new Error("Failed to build analysis prompt");
      }
      const response = await this.sendRequest(prompt);
      return this.parseResponse(response, mode, maxTags);
    } catch (error) {
      if (error instanceof Error && error.message.startsWith("Tag analysis failed:")) {
        throw error;
      }
      throw this.handleError(error, "Tag analysis");
    }
  }
  /**
   * Gets the maximum content length for the service implementation
   * Can be overridden by derived classes
   * @returns Maximum content length
   */
  getMaxContentLength() {
    return 4e3;
  }
};

// src/services/localService.ts
var LocalLLMService = class extends BaseLLMService {
  MAX_CONTENT_LENGTH = 4e3;
  MAX_RETRIES = 3;
  RETRY_DELAY = 1e3;
  // 1 second
  constructor(config, app) {
    super(config, app);
    this.endpoint = this.normalizeEndpoint(config.endpoint);
    this.validateLocalConfig();
  }
  normalizeEndpoint(endpoint) {
    endpoint = endpoint.trim();
    endpoint = endpoint.replace(/\/$/, "");
    if (!endpoint.endsWith("/v1/chat/completions")) {
      if (!endpoint.includes("/v1/")) {
        endpoint = `${endpoint}/v1/chat/completions`;
      }
    }
    return endpoint;
  }
  validateLocalConfig() {
    const baseError = this.validateConfig();
    if (baseError)
      return baseError;
    try {
      new URL(this.endpoint);
    } catch {
      return "Invalid endpoint URL format";
    }
    return null;
  }
  async makeRequest(options, timeoutMs) {
    try {
      const { controller, cleanup } = this.createRequestController(timeoutMs);
      try {
        const response = await fetch(this.endpoint, {
          ...options,
          signal: controller.signal
        });
        return response;
      } finally {
        cleanup();
      }
    } catch (error) {
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          throw new Error("Request timed out. Please check if your local LLM service is running and responsive.");
        }
      }
      throw error;
    }
  }
  async makeRequestWithRetry(options, timeoutMs) {
    let lastError = null;
    for (let i = 0; i < this.MAX_RETRIES; i++) {
      try {
        const response = await this.makeRequest(options, timeoutMs);
        if (response.ok) {
          return response;
        }
        const errorText = await response.text();
        lastError = new Error(
          `HTTP error ${response.status}: ${errorText || response.statusText}`
        );
      } catch (error) {
        lastError = error instanceof Error ? error : new Error("Unknown error");
      }
      await new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY * (i + 1)));
    }
    throw lastError || new Error("Max retries exceeded");
  }
  async testConnection() {
    try {
      const validationError = this.validateLocalConfig();
      if (validationError) {
        return {
          result: "failed" /* Failed */,
          error: {
            type: "network",
            message: validationError
          }
        };
      }
      const response = await this.makeRequestWithRetry({
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: this.modelName,
          messages: [{
            role: "system",
            content: "Simple connection test"
          }, {
            role: "user",
            content: "Hello"
          }],
          max_tokens: 5
        })
      }, 1e4);
      const responseText = await response.text();
      try {
        const data = JSON.parse(responseText);
        if (!data.choices || !Array.isArray(data.choices)) {
          throw new Error("Invalid response format");
        }
      } catch (parseError) {
        throw new Error("Failed to parse response from local service");
      }
      return { result: "success" /* Success */ };
    } catch (error) {
      let testError = {
        type: "unknown",
        message: "Unknown error"
      };
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          testError = {
            type: "timeout",
            message: "Connection timeout, please check if the local LLM service is running"
          };
        } else if (error.message.includes("Failed to fetch")) {
          testError = {
            type: "network",
            message: "Network error, please check if the local service is accessible"
          };
        } else if (error.message.includes("HTTP error")) {
          testError = {
            type: "network",
            message: `Service error: ${error.message}`
          };
        } else if (error.message.includes("Invalid response")) {
          testError = {
            type: "unknown",
            message: "Invalid response format from local service"
          };
        }
      }
      return {
        result: "failed" /* Failed */,
        error: testError
      };
    }
  }
  /**
   * Analyzes content and returns tag suggestions
   * @param content - Content to analyze
   * @param existingTags - Array of existing tags to consider
   * @param mode - Tagging mode
   * @param maxTags - Maximum number of tags to return
   * @param language - Language for generated tags
   * @returns Promise resolving to tag analysis result
   */
  async analyzeTags(content, existingTags, mode, maxTags, language) {
    return super.analyzeTags(content, existingTags, mode, maxTags, language);
  }
  /**
   * Sends a request to the LLM service and returns the response
   * @param prompt - The prompt to send
   * @returns Promise resolving to the response
   */
  async sendRequest(prompt) {
    const response = await this.makeRequestWithRetry({
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: this.modelName,
        messages: [
          {
            role: "system",
            content: SYSTEM_PROMPT
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.3
      })
    }, this.TIMEOUT);
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP error ${response.status}: ${errorText || response.statusText}`);
    }
    const data = await response.json();
    if (!data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
      throw new Error("Invalid response format from service");
    }
    return data.choices[0]?.message?.content || "";
  }
  /**
   * Gets the maximum content length for this service
   * @returns Maximum content length
   */
  getMaxContentLength() {
    return this.MAX_CONTENT_LENGTH;
  }
};

// src/services/adapters/baseAdapter.ts
var BaseAdapter = class extends BaseLLMService {
  config;
  provider;
  /**
   * Formats a request for the cloud service
   * Handles provider-specific request formats
   * @param prompt - The prompt to send to the LLM
   * @param language - Optional language code
   * @returns Formatted request body
   */
  formatRequest(prompt, language) {
    if (this.provider?.requestFormat?.body) {
      return {
        ...this.provider.requestFormat.body,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: prompt }
        ]
      };
    }
    return super.formatRequest(prompt, language);
  }
  parseResponse(response) {
    if (!this.provider?.responseFormat?.path) {
      throw new Error("Provider response format not configured");
    }
    try {
      if (response.error && this.provider.responseFormat.errorPath) {
        let errorMsg = response;
        for (const key of this.provider.responseFormat.errorPath) {
          errorMsg = errorMsg[key];
        }
        throw new Error(errorMsg || "Unknown error");
      }
      let result = response;
      for (const key of this.provider.responseFormat.path) {
        if (!result || typeof result !== "object") {
          throw new Error("Invalid response structure");
        }
        result = result[key];
      }
      if (typeof result === "string") {
        try {
          result = this.extractJsonFromContent(result);
        } catch (error) {
          const tags = this.extractTagsFromText(result);
          result = {
            matchedTags: [],
            newTags: tags
          };
        }
      }
      if (result.matchedTags && !Array.isArray(result.matchedTags)) {
        result.matchedTags = [];
      }
      if (result.newTags && !Array.isArray(result.newTags)) {
        result.newTags = [];
      }
      result.matchedTags = (result.matchedTags || []).map((tag) => String(tag).trim());
      result.newTags = (result.newTags || []).map((tag) => String(tag).trim());
      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse response: ${message}`);
    }
  }
  extractTagsFromText(text) {
    const hashtagRegex = /#[\p{L}\p{N}-]+/gu;
    const hashtags = text.match(hashtagRegex) || [];
    if (hashtags.length > 0) {
      return hashtags;
    }
    const potentialTagsRegex = /["']([a-zA-Z0-9-]+)["']|\s+[-*]\s+([a-zA-Z0-9-]+)/g;
    const potentialTags = [];
    let match;
    while ((match = potentialTagsRegex.exec(text)) !== null) {
      const tag = match[1] || match[2];
      if (tag) {
        potentialTags.push(`#${tag}`);
      }
    }
    return potentialTags;
  }
  validateConfig() {
    return super.validateConfig();
  }
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint ?? "",
      modelName: config.modelName ?? ""
    }, null);
    this.config = config;
  }
  async analyzeTags(content, existingTags) {
    const prompt = this.buildPrompt(content, existingTags, "hybrid" /* Hybrid */, 10, this.config.language);
    const response = await this.makeRequest(prompt);
    return this.parseResponse(response);
  }
  async testConnection() {
    try {
      const response = await this.makeRequest("test");
      return { result: { success: true } };
    } catch (error) {
      return { result: { success: false }, error };
    }
  }
  async makeRequest(prompt) {
    const headers = this.getHeaders();
    const body = this.formatRequest(prompt, this.config.language);
    const response = await fetch(this.getEndpoint(), {
      method: "POST",
      headers,
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      throw new Error(`Request failed: ${response.statusText}`);
    }
    return await response.json();
  }
  getEndpoint() {
    return this.config.endpoint ?? "";
  }
  getHeaders() {
    return {
      "Content-Type": "application/json"
    };
  }
  extractJsonFromContent(content) {
    try {
      const jsonMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[1]);
      }
      const standaloneJson = content.match(/\{[\s\S]*\}/);
      if (standaloneJson) {
        return JSON.parse(standaloneJson[0]);
      }
      throw new Error("No JSON found in response");
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse JSON: ${message}`);
    }
  }
  /**
   * Extracts the main content from a cloud provider response
   * @param response The response object from the cloud provider
   * @returns The extracted content as a string
   */
  parseResponseContent(response) {
    try {
      if (!this.provider?.responseFormat?.contentPath) {
        return response.choices?.[0]?.message?.content || "";
      }
      let content = response;
      for (const key of this.provider.responseFormat.contentPath) {
        if (!content || typeof content !== "object") {
          throw new Error("Invalid response structure");
        }
        content = content[key];
      }
      return typeof content === "string" ? content : JSON.stringify(content);
    } catch (error) {
      return "";
    }
  }
  /**
   * Sends a request to the LLM service
   * Abstract method implementation required by BaseLLMService
   * @param prompt - The prompt to send
   * @returns Promise resolving to the response
   */
  async sendRequest(prompt) {
    const response = await this.makeRequest(prompt);
    return this.parseResponseContent(response);
  }
};

// src/services/adapters/openaiAdapter.ts
var endpoints = __toESM(require_cloudEndpoints());
var OpenAIAdapter = class extends BaseAdapter {
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints.openai,
      modelName: config.modelName || "gpt-4-turbo-preview"
    });
    this.provider = {
      name: "openai",
      requestFormat: {
        url: "/v1/chat/completions",
        body: {
          model: this.config.modelName,
          messages: []
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for OpenAI");
    }
    return {
      "Authorization": `Bearer ${this.config.apiKey}`,
      "Content-Type": "application/json"
    };
  }
};

// src/services/adapters/geminiAdapter.ts
var endpoints2 = __toESM(require_cloudEndpoints());
var GeminiAdapter = class extends BaseAdapter {
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints2.gemini,
      modelName: config.modelName || "gemini-2.0-flash"
    });
    this.provider = {
      name: "gemini",
      requestFormat: {
        url: "/chat/completions",
        body: {
          model: this.config.modelName,
          messages: [],
          n: 1
        }
      },
      responseFormat: {
        path: ["choices", 0, "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Gemini");
    }
    return {
      "Authorization": `Bearer ${this.config.apiKey}`,
      "Content-Type": "application/json"
    };
  }
};

// src/services/adapters/openaiCompatibleAdapter.ts
var OpenAICompatibleAdapter = class extends BaseAdapter {
  constructor(config) {
    super(config);
    this.provider = {
      name: "openai-compatible",
      requestFormat: {
        url: config.endpoint || "/v1/chat/completions",
        headers: {},
        body: {
          model: this.config.modelName,
          messages: []
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  formatRequest(prompt) {
    const body = {
      model: this.config.modelName,
      messages: [{
        role: "system",
        content: SYSTEM_PROMPT
      }, {
        role: "user",
        content: prompt
      }]
    };
    for (const [key, value] of Object.entries(this.config)) {
      if (!["endpoint", "apiKey", "modelName"].includes(key)) {
        body[key] = value;
      }
    }
    return body;
  }
  parseResponse(response) {
    try {
      let content;
      if (response.choices?.[0]?.message?.content) {
        content = response.choices[0].message.content;
      } else if (response.choices?.[0]?.text) {
        content = response.choices[0].text;
      } else {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required";
    }
    if (!this.config.modelName) {
      return "Model name is required";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required";
    }
    return null;
  }
  extractError(error) {
    if (error.response?.data?.error?.message) {
      return error.response.data.error.message;
    }
    if (error.response?.data?.message) {
      return error.response.data.message;
    }
    return error.message || "Unknown error occurred";
  }
  getHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`,
      ...this.provider?.requestFormat.headers || {}
    };
  }
};

// src/services/adapters/index.ts
var cloudEndpoints = __toESM(require_cloudEndpoints());

// src/services/adapters/deepseekAdapter.ts
var endpoints3 = __toESM(require_cloudEndpoints());
var DeepseekAdapter = class extends BaseAdapter {
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints3.deepseek,
      modelName: config.modelName || "deepseek-chat"
    });
    this.provider = {
      name: "deepseek",
      requestFormat: {
        body: {
          model: this.modelName
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  getHeaders() {
    return {
      "Authorization": `Bearer ${this.config.apiKey}`,
      "Content-Type": "application/json"
    };
  }
  defaultConfig = {
    defaultModel: "deepseek-chat"
  };
  validateConfig() {
    const baseValidation = super.validateConfig();
    if (baseValidation)
      return baseValidation;
    if (!this.config.apiKey) {
      return "API key is required for Deepseek";
    }
    return null;
  }
  parseResponse(response) {
    try {
      let result = response;
      let content = "";
      if (response.choices?.[0]?.message?.content) {
        content = response.choices[0].message.content;
      }
      for (const key of this.provider.responseFormat.path) {
        if (!result || typeof result !== "object") {
          throw new Error("Invalid response structure");
        }
        result = result[key];
      }
      const jsonContent = this.extractJsonFromContent(content);
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags || [],
        suggestedTags: jsonContent.newTags || []
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Deepseek response: ${message}`);
    }
  }
};

// src/services/adapters/aliyunAdapter.ts
var endpoints4 = __toESM(require_cloudEndpoints());
var AliyunAdapter = class extends BaseAdapter {
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints4.aliyun,
      modelName: config.modelName || "qwen-max"
    });
    this.provider = {
      name: "aliyun",
      requestFormat: {
        body: {
          model: this.config.modelName || "qwen-max"
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  parseResponse(response) {
    try {
      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      let jsonContent;
      try {
        jsonContent = this.extractJsonFromContent(content);
      } catch (jsonError) {
        try {
          if (typeof content === "string" && (content.trim().startsWith("{") && content.trim().endsWith("}"))) {
            jsonContent = JSON.parse(content);
          }
        } catch (directParseError) {
        }
        if (!jsonContent) {
          const hashtagRegex = /#[\p{L}\p{N}-]+/gu;
          const hashtags = content.match(hashtagRegex) || [];
          return {
            text: content,
            matchedExistingTags: [],
            suggestedTags: hashtags
          };
        }
      }
      if (!Array.isArray(jsonContent?.matchedTags) && !Array.isArray(jsonContent?.newTags)) {
        const matchedTags = Array.isArray(jsonContent?.matchedExistingTags) ? jsonContent.matchedExistingTags : Array.isArray(jsonContent?.existingTags) ? jsonContent.existingTags : [];
        const newTags = Array.isArray(jsonContent?.suggestedTags) ? jsonContent.suggestedTags : Array.isArray(jsonContent?.generatedTags) ? jsonContent.generatedTags : [];
        if (matchedTags.length > 0 || newTags.length > 0) {
          return {
            text: content,
            matchedExistingTags: matchedTags,
            suggestedTags: newTags
          };
        }
        if (Array.isArray(jsonContent?.tags)) {
          return {
            text: content,
            matchedExistingTags: [],
            suggestedTags: jsonContent.tags
          };
        }
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags || [],
        suggestedTags: jsonContent.newTags || []
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Aliyun response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for Aliyun";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for Aliyun";
    }
    return null;
  }
  extractError(error) {
    if (error.response?.data?.error?.message) {
      return error.response.data.error.message;
    }
    return error.message || "Unknown error occurred";
  }
  getHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`,
      ...this.provider?.requestFormat.headers || {}
    };
  }
};

// src/services/adapters/claudeAdapter.ts
var endpoints5 = __toESM(require_cloudEndpoints());
var ClaudeAdapter = class extends BaseAdapter {
  anthropicVersion = "2023-06-01";
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints5.claude,
      modelName: config.modelName || "claude-3-opus-20240229"
    });
    this.provider = {
      name: "claude",
      requestFormat: {
        url: "/v1/messages",
        headers: {
          "anthropic-version": this.anthropicVersion
        },
        body: {
          model: this.config.modelName,
          messages: [],
          max_tokens: 1024
        }
      },
      responseFormat: {
        path: ["content", "0", "text"],
        errorPath: ["error", "message"]
      }
    };
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Claude");
    }
    return {
      "Content-Type": "application/json",
      "anthropic-version": this.anthropicVersion,
      "x-api-key": this.config.apiKey
    };
  }
};

// src/services/adapters/groqAdapter.ts
var endpoints6 = __toESM(require_cloudEndpoints());
var GroqAdapter = class extends BaseAdapter {
  defaultConfig = {
    temperature: 0.7,
    defaultModel: "mixtral-8x7b-32768"
  };
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints6.groq
    });
    this.provider = {
      name: "groq",
      requestFormat: {
        url: "/v1/chat/completions",
        headers: {},
        body: {
          model: config.modelName || this.defaultConfig.defaultModel,
          messages: [],
          temperature: this.defaultConfig.temperature
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  formatRequest(prompt) {
    const baseRequest = super.formatRequest(prompt);
    return {
      ...baseRequest,
      temperature: this.defaultConfig.temperature
    };
  }
  parseResponse(response) {
    try {
      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Groq response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for Groq";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for Groq";
    }
    return null;
  }
  extractError(error) {
    const message = error.error?.message || error.response?.data?.error?.message || error.message || "Unknown error occurred";
    return message;
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Groq");
    }
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`
    };
  }
};

// src/services/adapters/vertexAdapter.ts
var endpoints7 = __toESM(require_cloudEndpoints());
var VertexAdapter = class extends BaseAdapter {
  defaultConfig = {
    temperature: 0.7,
    maxOutputTokens: 1024,
    topP: 0.8,
    topK: 40
  };
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints7.vertex
    });
    this.provider = {
      name: "vertex",
      requestFormat: {
        url: "/predict",
        headers: {},
        body: {
          instances: [{
            messages: []
          }],
          parameters: this.defaultConfig
        }
      },
      responseFormat: {
        path: ["predictions", "0", "candidates", "0", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  formatRequest(prompt) {
    const messages = [
      {
        role: "system",
        content: SYSTEM_PROMPT
      },
      {
        role: "user",
        content: prompt
      }
    ];
    const baseRequest = super.formatRequest(prompt);
    return {
      ...baseRequest,
      model: this.config.modelName || "gemini-pro",
      maxTokens: this.defaultConfig.maxOutputTokens,
      ...this.defaultConfig,
      _vertex: {
        instances: [{
          messages: messages.map((m) => ({
            author: m.role,
            content: m.content
          }))
        }],
        parameters: this.defaultConfig
      }
    };
  }
  parseResponse(response) {
    try {
      const content = response.predictions?.[0]?.candidates?.[0]?.content;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Vertex AI response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for Vertex AI";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for Vertex AI";
    }
    return null;
  }
  extractError(error) {
    const message = error.error?.message || error.response?.data?.error?.message || error.message || "Unknown error occurred";
    return message;
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Vertex AI");
    }
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`,
      "x-goog-user-project": this.extractProjectId(),
      "x-goog-api-key": this.config.apiKey
    };
  }
  extractProjectId() {
    const match = this.config.endpoint?.match(/projects\/([^/]+)/);
    return match?.[1] || "";
  }
};

// src/services/adapters/openRouterAdapter.ts
var endpoints8 = __toESM(require_cloudEndpoints());
var OpenRouterAdapter = class extends BaseAdapter {
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints8.openrouter
    });
    this.provider = {
      name: "openrouter",
      requestFormat: {
        body: {
          model: this.config.modelName
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  parseResponse(response) {
    try {
      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse OpenRouter response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for OpenRouter";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for OpenRouter";
    }
    if (!this.config.modelName) {
      return "Model name is required for OpenRouter";
    }
    return null;
  }
  extractError(error) {
    return error.error?.message || error.response?.data?.error?.message || error.message || "Unknown error occurred";
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for OpenRouter");
    }
    return {
      ...super.getHeaders(),
      "Authorization": `Bearer ${this.config.apiKey}`,
      "HTTP-Referer": "https://github.com/obsidian-ai-tagger",
      "X-Title": "Obsidian AI Tagger"
    };
  }
};

// src/services/adapters/bedrockAdapter.ts
var endpoints9 = __toESM(require_cloudEndpoints());
var BedrockAdapter = class extends BaseAdapter {
  defaultConfig = {
    max_tokens: 1024,
    temperature: 0.7
  };
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints9.bedrock,
      modelName: config.modelName || "anthropic.claude-3-haiku-20240307-v1:0"
    });
    this.provider = {
      name: "bedrock",
      requestFormat: {
        url: "/model/invoke",
        headers: {},
        body: {
          model: this.modelName
        }
      },
      responseFormat: {
        path: ["completion"],
        errorPath: ["errorMessage"]
      }
    };
  }
  formatRequest(prompt) {
    const modelName = this.config.modelName || "";
    const baseRequest = super.formatRequest(prompt);
    if (modelName.includes("claude")) {
      return {
        ...baseRequest,
        prompt: `

Human: ${prompt}

Assistant: `,
        ...this.defaultConfig,
        anthropic_version: "2023-01-01"
      };
    } else if (modelName.includes("titan")) {
      return {
        ...baseRequest,
        inputText: prompt,
        textGenerationConfig: {
          maxTokenCount: this.defaultConfig.max_tokens,
          temperature: this.defaultConfig.temperature,
          stopSequences: []
        }
      };
    }
    return {
      ...baseRequest,
      prompt,
      ...this.defaultConfig
    };
  }
  parseResponse(response) {
    try {
      let content = "";
      const modelName = this.config.modelName || "";
      if (modelName.includes("claude")) {
        content = response.completion || "";
      } else if (modelName.includes("titan")) {
        content = response.results?.[0]?.outputText || "";
      } else {
        content = response.generation || "";
      }
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Bedrock response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for AWS Bedrock";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for AWS Bedrock";
    }
    if (!this.config.modelName) {
      return "Model name is required for AWS Bedrock";
    }
    return null;
  }
  extractError(error) {
    return error.errorMessage || error.response?.data?.errorMessage || error.message || "Unknown error occurred";
  }
  getHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`
    };
  }
};

// src/services/adapters/requestyAdapter.ts
var endpoints10 = __toESM(require_cloudEndpoints());
var RequestyAdapter = class extends BaseAdapter {
  defaultConfig = {
    temperature: 0.7,
    max_tokens: 1024
  };
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints10.requesty
    });
    this.provider = {
      name: "requesty",
      requestFormat: {
        url: "/v1/chat/completions",
        headers: {},
        body: {
          model: config.modelName,
          messages: [],
          ...this.defaultConfig
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  formatRequest(prompt) {
    const baseRequest = super.formatRequest(prompt);
    return {
      ...baseRequest,
      ...this.defaultConfig
    };
  }
  parseResponse(response) {
    try {
      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Requesty response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for Requesty AI";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for Requesty AI";
    }
    if (!this.config.modelName) {
      return "Model name is required for Requesty AI";
    }
    return null;
  }
  extractError(error) {
    return error.error?.message || error.response?.data?.error?.message || error.message || "Unknown error occurred";
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Requesty AI");
    }
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`,
      ...this.provider?.requestFormat.headers || {}
    };
  }
};

// src/services/adapters/cohereAdapter.ts
var endpoints11 = __toESM(require_cloudEndpoints());
var CohereAdapter = class extends BaseAdapter {
  defaultConfig = {
    temperature: 0.7,
    chat_history: [],
    stream: false
  };
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints11.cohere
    });
    this.provider = {
      name: "cohere",
      requestFormat: {
        url: "/v1/chat",
        headers: {},
        body: {
          model: config.modelName,
          message: "",
          ...this.defaultConfig
        }
      },
      responseFormat: {
        path: ["text"],
        errorPath: ["message"]
      }
    };
  }
  formatRequest(prompt) {
    const baseRequest = super.formatRequest(prompt);
    return {
      ...baseRequest,
      message: prompt,
      ...this.defaultConfig,
      connectors: []
    };
  }
  parseResponse(response) {
    try {
      const content = response.text;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Cohere response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for Cohere";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for Cohere";
    }
    if (!this.config.modelName) {
      return "Model name is required for Cohere";
    }
    return null;
  }
  extractError(error) {
    return error.message || error.response?.data?.message || "Unknown error occurred";
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Cohere");
    }
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`,
      "Accept": "application/json"
    };
  }
};

// src/services/adapters/grokAdapter.ts
var endpoints12 = __toESM(require_cloudEndpoints());
var GrokAdapter = class extends BaseAdapter {
  defaultConfig = {
    max_tokens: 2048,
    temperature: 0.7
  };
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints12.grok
    });
    this.provider = {
      name: "grok",
      requestFormat: {
        url: "/v1/chat/completions",
        headers: {},
        body: {
          model: config.modelName,
          messages: [],
          ...this.defaultConfig
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  formatRequest(prompt) {
    const baseRequest = super.formatRequest(prompt);
    return {
      ...baseRequest,
      ...this.defaultConfig
    };
  }
  parseResponse(response) {
    try {
      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error("Invalid response format: missing content");
      }
      const jsonContent = this.extractJsonFromContent(content);
      if (!Array.isArray(jsonContent?.matchedTags) || !Array.isArray(jsonContent?.newTags)) {
        throw new Error("Invalid response format: missing required arrays");
      }
      return {
        text: content,
        matchedExistingTags: jsonContent.matchedTags,
        suggestedTags: jsonContent.newTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to parse Grok response: ${message}`);
    }
  }
  validateConfig() {
    if (!this.config.apiKey) {
      return "API key is required for Grok";
    }
    if (!this.config.endpoint) {
      return "Endpoint is required for Grok";
    }
    if (!this.config.modelName) {
      return "Model name is required for Grok";
    }
    return null;
  }
  extractError(error) {
    return error.error?.message || error.response?.data?.error?.message || error.message || "Unknown error occurred";
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Grok");
    }
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`
    };
  }
};

// src/services/adapters/mistralAdapter.ts
var endpoints13 = __toESM(require_cloudEndpoints());
var MistralAdapter = class extends BaseAdapter {
  constructor(config) {
    super({
      ...config,
      endpoint: config.endpoint || endpoints13.mistral,
      modelName: config.modelName || "mistral-large-latest"
    });
    this.provider = {
      name: "mistral",
      requestFormat: {
        url: "/v1/chat/completions",
        body: {
          model: this.config.modelName,
          messages: [],
          temperature: 0.7,
          max_tokens: 1024,
          safe_mode: true
        }
      },
      responseFormat: {
        path: ["choices", "0", "message", "content"],
        errorPath: ["error", "message"]
      }
    };
  }
  getHeaders() {
    if (!this.config.apiKey) {
      throw new Error("API key is required for Mistral AI");
    }
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.config.apiKey}`
    };
  }
};

// src/services/adapters/index.ts
function createAdapter(type2, config) {
  switch (type2.toLowerCase()) {
    case "openai":
      return new OpenAIAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.openai
      });
    case "gemini":
      return new GeminiAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.gemini
      });
    case "deepseek":
      return new DeepseekAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.deepseek
      });
    case "aliyun":
      return new AliyunAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.aliyun
      });
    case "claude":
      return new ClaudeAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.claude
      });
    case "groq":
      return new GroqAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.groq
      });
    case "vertex":
      return new VertexAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.vertex
      });
    case "openrouter":
      return new OpenRouterAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.openrouter
      });
    case "bedrock":
      return new BedrockAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.bedrock
      });
    case "requesty":
      return new RequestyAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.requesty
      });
    case "cohere":
      return new CohereAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.cohere
      });
    case "grok":
      return new GrokAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.grok
      });
    case "mistral":
      return new MistralAdapter({
        ...config,
        endpoint: config.endpoint || cloudEndpoints.mistral
      });
    case "openai-compatible":
      return new OpenAICompatibleAdapter(config);
    default:
      throw new Error(`Unsupported adapter type: ${type2}`);
  }
}

// src/services/cloudService.ts
var CloudLLMService = class extends BaseLLMService {
  adapter;
  MAX_CONTENT_LENGTH = 4e3;
  // Reasonable limit for most APIs
  MAX_RETRIES = 3;
  RETRY_DELAY = 1e3;
  // 1 second
  constructor(config, app) {
    super(config, app);
    this.adapter = createAdapter(config.type, {
      endpoint: config.endpoint,
      apiKey: config.apiKey || "",
      modelName: config.modelName,
      language: config.language
    });
  }
  validateCloudConfig() {
    const baseError = this.validateConfig();
    if (baseError)
      return baseError;
    const adapterError = this.adapter.validateConfig();
    if (adapterError)
      return adapterError;
    return null;
  }
  async makeRequest(prompt, timeoutMs) {
    try {
      const validationError = this.validateCloudConfig();
      if (validationError) {
        throw new Error(validationError);
      }
      const { controller, cleanup } = this.createRequestController(timeoutMs);
      try {
        const response = await fetch(this.adapter.getEndpoint(), {
          method: "POST",
          headers: this.adapter.getHeaders(),
          body: JSON.stringify(this.adapter.formatRequest(prompt)),
          signal: controller.signal
        });
        return response;
      } finally {
        cleanup();
      }
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        throw new Error("Request timed out");
      }
      throw error;
    }
  }
  async makeRequestWithRetry(prompt, timeoutMs) {
    let lastError = null;
    for (let i = 0; i < this.MAX_RETRIES; i++) {
      try {
        const response = await this.makeRequest(prompt, timeoutMs);
        if (response.ok || response.status === 401) {
          return response;
        }
        lastError = new Error(`HTTP error ${response.status}`);
      } catch (error) {
        lastError = error instanceof Error ? error : new Error("Unknown error");
        if (error instanceof Error && error.message.includes("Invalid API key")) {
          throw error;
        }
      }
      if (i < this.MAX_RETRIES - 1) {
        await new Promise((resolve) => setTimeout(resolve, this.RETRY_DELAY * (i + 1)));
      }
    }
    throw lastError || new Error("Max retries exceeded");
  }
  async testConnection() {
    try {
      const response = await this.makeRequestWithRetry("Connection test", 1e4);
      const responseText = await response.text();
      if (!response.ok) {
        if (response.status === 401) {
          throw new Error("Authentication failed: Invalid API key");
        } else if (response.status === 404) {
          throw new Error("API endpoint not found: Please verify the URL");
        }
        try {
          const errorJson = JSON.parse(responseText);
          throw new Error(errorJson.error?.message || errorJson.message || `HTTP error ${response.status}`);
        } catch {
          throw new Error(`HTTP error ${response.status}: ${responseText}`);
        }
      }
      const data = JSON.parse(responseText);
      if (!data.choices || !Array.isArray(data.choices)) {
        throw new Error("Invalid API response format: missing choices array");
      }
      return { result: "success" /* Success */ };
    } catch (error) {
      let testError = {
        type: "unknown",
        message: "Unknown error occurred during connection test"
      };
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          testError = {
            type: "timeout",
            message: "Connection timeout: Please check your network status"
          };
        } else if (error.message.includes("Failed to fetch")) {
          testError = {
            type: "network",
            message: "Network error: Unable to reach the API endpoint"
          };
        } else if (error.message.includes("Authentication failed")) {
          testError = {
            type: "auth",
            message: "Authentication failed: Please verify your API key"
          };
        } else if (error.message.includes("API endpoint not found")) {
          testError = {
            type: "network",
            message: "API endpoint not found: Please verify the URL"
          };
        } else {
          testError = {
            type: "unknown",
            message: `Error: ${error.message}`
          };
        }
      }
      return {
        result: "failed" /* Failed */,
        error: testError
      };
    }
  }
  /**
   * Analyzes content and returns tag suggestions
   * @param content - Content to analyze
   * @param existingTags - Array of existing tags to consider
   * @param mode - Tagging mode
   * @param maxTags - Maximum number of tags to return
   * @param language - Language for generated tags
   * @returns Promise resolving to tag analysis result
   */
  async analyzeTags(content, existingTags, mode, maxTags, language) {
    return super.analyzeTags(content, existingTags, mode, maxTags, language);
  }
  /**
   * Sends a request to the LLM service and returns the response
   * @param prompt - The prompt to send 
   * @returns Promise resolving to the response
   */
  async sendRequest(prompt) {
    const response = await this.makeRequestWithRetry(prompt, this.TIMEOUT);
    if (!response.ok) {
      const responseText2 = await response.text();
      try {
        const errorJson = JSON.parse(responseText2);
        throw new Error(errorJson.error?.message || errorJson.message || `API error: ${response.status}`);
      } catch {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
    }
    const responseText = await response.text();
    try {
      const data = JSON.parse(responseText);
      const content = this.adapter.parseResponseContent(data);
      if (!content) {
        throw new Error("No content found in response");
      }
      return content;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error(`Failed to parse response: ${responseText.substring(0, 100)}...`);
    }
  }
  /**
   * Gets the maximum content length for this service
   * @returns Maximum content length
   */
  getMaxContentLength() {
    return this.MAX_CONTENT_LENGTH;
  }
};

// src/ui/modals/ConfirmationModal.ts
var import_obsidian = require("obsidian");
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.containerEl.addClass("ai-tagger-modal-container");
    this.contentEl.addClass("ai-tagger-modal-content");
    const titleEl = this.contentEl.createEl("h3", {
      cls: "ai-tagger-modal-title",
      text: `${title}`
    });
    const messageEl = this.contentEl.createEl("p", {
      cls: "ai-tagger-modal-message",
      text: message
    });
    const buttonContainer = this.contentEl.createDiv("ai-tagger-modal-buttons");
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => this.close());
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Confirm").setCta().onClick(() => {
      onConfirm();
      this.close();
    });
  }
};

// src/utils/tagUtils.ts
var import_obsidian2 = require("obsidian");
var path = __toESM(require("path"));

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/utils/tagUtils.ts
var TagError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TagError";
  }
};
var TagUtils = class {
  /**
   * Gets existing tags from frontmatter
   * @param frontmatter - The frontmatter object from Obsidian's metadata cache
   * @returns Array of valid tags
   */
  static getExistingTags(frontmatter) {
    if (!frontmatter)
      return [];
    if (!("tags" in frontmatter) || frontmatter.tags === null || frontmatter.tags === void 0)
      return [];
    try {
      const tags = Array.isArray(frontmatter.tags) ? frontmatter.tags : typeof frontmatter.tags === "string" ? [frontmatter.tags] : [];
      return tags.filter((tag) => tag !== null && tag !== void 0).map((tag) => String(tag));
    } catch (error) {
      return [];
    }
  }
  /**
   * Merges two arrays of tags, removing duplicates and sorting
   * @param existingTags - Array of existing tags
   * @param newTags - Array of new tags to merge
   * @returns Array of unique, sorted tags
   */
  static mergeTags(existingTags, newTags) {
    const validExisting = existingTags.map((tag) => String(tag));
    const validNew = newTags.map((tag) => String(tag));
    return [.../* @__PURE__ */ new Set([...validExisting, ...validNew])].sort();
  }
  /**
   * Formats a tag to ensure consistent formatting
   * @param tag - Tag to format
   * @returns Properly formatted tag
   */
  static formatTag(tag) {
    if (tag === null || tag === void 0) {
      return "";
    }
    const tagStr = typeof tag === "string" ? tag : String(tag);
    let formatted = tagStr.trim();
    if (formatted.startsWith("#")) {
      formatted = formatted.substring(1);
    }
    formatted = formatted.replace(/\s+/g, "-");
    formatted = formatted.replace(/[^\p{L}\p{N}-]/gu, "-");
    formatted = formatted.replace(/-{2,}/g, "-");
    formatted = formatted.replace(/^-+|-+$/g, "");
    return formatted.length > 0 ? formatted : "";
  }
  /**
   * Clears all tags from a file's frontmatter using Obsidian API.
   * @param app - Obsidian App instance
   * @param file - File to clear tags from
   * @returns Promise resolving to operation result
   */
  static async clearTags(app, file) {
    try {
      const content = await app.vault.read(file);
      const cache = app.metadataCache.getFileCache(file);
      const frontmatterPosition = cache?.frontmatterPosition;
      if (!frontmatterPosition) {
        return { success: true, message: "Skipped: Note has no frontmatter", tags: [] };
      }
      const frontmatterText = content.substring(
        frontmatterPosition.start.offset + 4,
        // Skip '---\n'
        frontmatterPosition.end.offset - 4
        // Skip '\n---'
      );
      let frontmatter;
      try {
        frontmatter = load(frontmatterText) || {};
      } catch (yamlError) {
        return {
          success: false,
          message: "YAML parse error: " + (yamlError instanceof Error ? yamlError.message : String(yamlError)),
          tags: []
        };
      }
      if (!frontmatter || typeof frontmatter !== "object") {
        return { success: true, message: "No valid frontmatter", tags: [] };
      }
      if (!("tags" in frontmatter)) {
        return { success: true, message: "No tags to clear", tags: [] };
      }
      const tagsToRemove = Array.isArray(frontmatter.tags) ? frontmatter.tags.map(String) : typeof frontmatter.tags === "string" ? [frontmatter.tags] : [];
      delete frontmatter.tags;
      const newFrontmatter = dump(frontmatter).trim();
      const newContent = "---\n" + newFrontmatter + "\n---" + content.substring(frontmatterPosition.end.offset);
      if (newContent !== content) {
        try {
          await app.vault.modify(file, newContent);
          await new Promise((resolve) => setTimeout(resolve, 300));
        } catch (modifyError) {
          throw new Error(`Failed to modify file: ${modifyError instanceof Error ? modifyError.message : String(modifyError)}`);
        }
      }
      const removedTags = tagsToRemove.map((tag) => `#${tag}`);
      return {
        success: true,
        message: `Cleared ${removedTags.length} tag${removedTags.length === 1 ? "" : "s"}`,
        tags: removedTags
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      new import_obsidian2.Notice(`Error clearing tags: ${message}`, 3e3);
      return {
        success: false,
        message: `Clear failed: ${message}`
      };
    }
  }
  /**
   * Updates note tags in the frontmatter using Obsidian API
   * @param app - Obsidian App instance
   * @param file - File to update tags for
   * @param newTags - Array of new tags to add
   * @param matchedTags - Array of matched existing tags to add
   * @param silent - Whether to suppress notifications
   * @param replaceTags - Whether to replace existing tags (true) or merge with them (false)
   * @returns Promise resolving to operation result
   */
  static async updateNoteTags(app, file, newTags, matchedTags, silent = false, replaceTags = true) {
    try {
      if (!Array.isArray(newTags) || !Array.isArray(matchedTags)) {
        throw new TagError("Tags parameter must be an array");
      }
      const allTags = [...newTags, ...matchedTags];
      const yamlReadyTags = this.formatTags(allTags);
      if (yamlReadyTags.length === 0) {
        !silent && new import_obsidian2.Notice("No valid tags to add", 3e3);
        return { success: true, message: "No valid tags to add", tags: [] };
      }
      const content = await app.vault.read(file);
      try {
        const cache = app.metadataCache.getFileCache(file);
        const existingFrontmatter = cache?.frontmatter;
        if (!replaceTags && existingFrontmatter) {
          const existingTags = Array.isArray(existingFrontmatter.tags) ? existingFrontmatter.tags.map(String) : typeof existingFrontmatter.tags === "string" ? [existingFrontmatter.tags] : [];
          if (existingTags.length > 0) {
            const combined = this.mergeTags(existingTags, yamlReadyTags);
            yamlReadyTags.length = 0;
            yamlReadyTags.push(...combined);
          }
          const existingSet = new Set(existingTags.map((t) => t.toString().trim()));
          const newSet = new Set(yamlReadyTags.map((t) => t.toString().trim()));
          if (existingSet.size === newSet.size && [...existingSet].every((t) => newSet.has(t))) {
            const successMessage2 = `Tags already up to date (${yamlReadyTags.length} tag${yamlReadyTags.length === 1 ? "" : "s"})`;
            !silent && new import_obsidian2.Notice(successMessage2, 3e3);
            return {
              success: true,
              message: successMessage2,
              tags: yamlReadyTags.map((tag) => `#${tag}`)
            };
          }
        }
      } catch (compareError) {
      }
      try {
        const processor = app.metadataCache.getFileCache(file);
        const frontmatterPosition = processor?.frontmatterPosition;
        let newContent;
        if (frontmatterPosition) {
          const frontmatterText = content.substring(
            frontmatterPosition.start.offset + 4,
            // Skip '---\n'
            frontmatterPosition.end.offset - 4
            // Skip '\n---'
          );
          let frontmatter;
          try {
            frontmatter = load(frontmatterText) || {};
          } catch (e) {
            frontmatter = {};
          }
          frontmatter.tags = yamlReadyTags;
          const newFrontmatter = dump(frontmatter).trim();
          newContent = "---\n" + newFrontmatter + "\n---" + content.substring(frontmatterPosition.end.offset);
        } else {
          const frontmatter = { tags: yamlReadyTags };
          const newFrontmatter = dump(frontmatter).trim();
          newContent = "---\n" + newFrontmatter + "\n---\n\n" + content;
        }
        if (newContent !== content) {
          await app.vault.modify(file, newContent);
          await new Promise((resolve) => setTimeout(resolve, 300));
        }
      } catch (updateError) {
        throw new Error(`Failed to update frontmatter: ${updateError instanceof Error ? updateError.message : String(updateError)}`);
      }
      const successMessage = `${replaceTags ? "Replaced" : "Added"} ${yamlReadyTags.length} tag${yamlReadyTags.length === 1 ? "" : "s"}`;
      !silent && new import_obsidian2.Notice(successMessage, 3e3);
      return {
        success: true,
        message: successMessage,
        tags: yamlReadyTags.map((tag) => `#${tag}`)
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      !silent && new import_obsidian2.Notice(`Error updating tags: ${message}`, 3e3);
      return {
        success: false,
        message: `Update failed: ${message}`
      };
    }
  }
  /**
   * Waits for Obsidian's metadata cache to update for a file
   * @param app - Obsidian App instance
   * @param file - File to wait for
   * @returns Promise that resolves when metadata is updated
   */
  static async waitForMetadataUpdate(app, file) {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        app.metadataCache.off("changed", eventHandler);
        console.warn("Metadata update timeout, continuing anyway");
        resolve();
      }, 2e3);
      const eventHandler = (...args) => {
        try {
          const changedFile = args[0];
          if (changedFile?.path === file.path) {
            clearTimeout(timeout);
            app.metadataCache.off("changed", eventHandler);
            setTimeout(resolve, 50);
          }
        } catch (error) {
          console.warn("Error in metadata change handler:", error);
          clearTimeout(timeout);
          app.metadataCache.off("changed", eventHandler);
          resolve();
        }
      };
      app.metadataCache.on("changed", eventHandler);
      try {
        app.metadataCache.trigger("changed", file);
      } catch (error) {
        console.warn("Error triggering metadata change:", error);
        setTimeout(resolve, 50);
      }
    });
  }
  /**
   * Gets all unique tags from all markdown files in the vault
   * @param app - Obsidian App instance
   * @returns Array of unique tags, sorted alphabetically
   */
  static getAllTagsFromFrontmatter(app) {
    const tags = /* @__PURE__ */ new Set();
    app.vault.getMarkdownFiles().forEach((file) => {
      const cache = app.metadataCache.getFileCache(file);
      if (cache?.frontmatter?.tags) {
        this.getExistingTags(cache.frontmatter).forEach((tag) => tags.add(tag));
      }
    });
    return Array.from(tags).sort();
  }
  static getAllTags(app) {
    return this.getAllTagsFromFrontmatter(app);
  }
  /**
   * Saves all unique tags to a markdown file in the specified directory
   * @param app - Obsidian App instance
   * @param tagDir - Directory to save tags file in (default: 'tags')
   * @throws {TagError} If file operations fail
   */
  static async saveAllTags(app, tagDir = "tags") {
    const tags = this.getAllTagsFromFrontmatter(app);
    const formattedTags = tags.map((tag) => tag.startsWith("#") ? tag.substring(1) : tag).join("\n");
    const vault = app.vault;
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const dateStr = `${year}${month}${day}`;
    const folderPath = tagDir;
    const filePath = path.join(folderPath, `tags_${dateStr}.md`);
    const modal = new ConfirmationModal(
      app,
      "Save Tags",
      `Tags will be saved to: ${filePath}
Do you want to continue?`,
      async () => {
        try {
          const folder = vault.getAbstractFileByPath(folderPath);
          if (!folder) {
            try {
              await vault.createFolder(folderPath);
            } catch (e) {
              if (!(e instanceof Error) || !e.message.includes("already exists")) {
                throw e;
              }
            }
          }
          const file = vault.getAbstractFileByPath(filePath);
          if (!file) {
            await vault.create(filePath, formattedTags);
          } else {
            await vault.modify(file, formattedTags);
          }
          new import_obsidian2.Notice(`Tags saved to ${filePath}`, 3e3);
        } catch (error) {
          const message = error instanceof Error ? error.message : "Unknown error";
          new import_obsidian2.Notice(`Error saving tags: ${message}`, 3e3);
          throw new TagError(`Failed to save tags: ${message}`);
        }
      }
    );
    modal.open();
  }
  /**
   * Gets tags from a specified file
   * @param app - Obsidian App instance
   * @param filePath - Path to the tags file
   * @returns Promise resolving to an array of tags, or null if file not found
   */
  static async getTagsFromFile(app, filePath) {
    try {
      if (!filePath) {
        return null;
      }
      const file = app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian2.TFile)) {
        return null;
      }
      const content = await app.vault.read(file);
      return content.split("\n").map((line) => line.trim()).filter(Boolean).map((tag) => this.formatTag(tag));
    } catch (error) {
      return null;
    }
  }
  /**
   * Formats an array of tags, filtering out invalid ones
   * @param tags - Array of tags to format
   * @param keepHashPrefix - Whether to keep # prefix in the returned tags
   * @returns Array of formatted valid tags
   */
  static formatTags(tags, keepHashPrefix = false) {
    if (!Array.isArray(tags)) {
      return [];
    }
    return tags.filter((tag) => tag !== null && tag !== void 0).map((tag) => {
      try {
        const formatted = this.formatTag(tag);
        return keepHashPrefix ? `#${formatted}` : formatted;
      } catch (error) {
        return null;
      }
    }).filter((tag) => tag !== null);
  }
  /**
   * Writes tags to a note's frontmatter
   * @param app - Obsidian App instance
   * @param file - File to update
   * @param tags - Array of tags to add
   * @param replace - Whether to replace existing tags (default: false)
   * @returns Promise resolving to operation result
   */
  static async writeTagsToFrontmatter(app, file, tags, replace = false) {
    try {
      if (!Array.isArray(tags)) {
        throw new Error("Tags parameter must be an array");
      }
      const formattedTags = this.formatTags(tags);
      if (formattedTags.length === 0) {
        return {
          success: true,
          message: "No valid tags to add",
          tags: []
        };
      }
      const content = await app.vault.read(file);
      const cache = app.metadataCache.getFileCache(file);
      let finalTags;
      if (replace) {
        finalTags = formattedTags;
      } else {
        const existingTags = cache && cache.frontmatter ? this.getExistingTags(cache.frontmatter) : [];
        finalTags = this.mergeTags(existingTags, formattedTags);
      }
      let newContent;
      const frontmatterPosition = cache?.frontmatterPosition;
      if (frontmatterPosition) {
        try {
          const frontmatterText = content.substring(
            frontmatterPosition.start.offset + 4,
            // Skip '---\n'
            frontmatterPosition.end.offset - 4
            // Skip '\n---'
          );
          let frontmatter;
          try {
            frontmatter = load(frontmatterText) || {};
          } catch (yamlError) {
            throw new Error(`YAML parse error: ${yamlError instanceof Error ? yamlError.message : String(yamlError)}`);
          }
          frontmatter.tags = finalTags;
          const newFrontmatter = dump(frontmatter).trim();
          newContent = "---\n" + newFrontmatter + "\n---" + content.substring(frontmatterPosition.end.offset);
        } catch (error) {
          const yamlTags = finalTags.map((tag) => `  - ${tag}`).join("\n");
          newContent = `---
tags:
${yamlTags}
---
${content}`;
        }
      } else {
        const yamlTags = finalTags.map((tag) => `  - ${tag}`).join("\n");
        newContent = `---
tags:
${yamlTags}
---
${content}`;
      }
      await app.vault.modify(file, newContent);
      await new Promise((resolve) => setTimeout(resolve, 300));
      return {
        success: true,
        message: `Added ${finalTags.length} tag${finalTags.length === 1 ? "" : "s"}`,
        tags: finalTags.map((tag) => `#${tag}`)
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return {
        success: false,
        message: `Failed to update tags: ${message}`
      };
    }
  }
  /**
   * Checks if a file should be excluded based on patterns
   * @param file - The file to check
   * @param excludePatterns - Array of exclusion patterns
   * @returns True if the file should be excluded, false otherwise
   */
  static isFileExcluded(file, excludePatterns) {
    if (!excludePatterns || excludePatterns.length === 0) {
      return false;
    }
    const filePath = file.path;
    for (const pattern of excludePatterns) {
      try {
        if (this.matchesGlobPattern(filePath, pattern)) {
          return true;
        }
        if (filePath.toLowerCase().includes(pattern.toLowerCase())) {
          return true;
        }
        if (pattern.startsWith("/") && pattern.endsWith("/") && pattern.length > 2) {
          const regexPattern = pattern.slice(1, -1);
          try {
            const regex = new RegExp(regexPattern, "i");
            if (regex.test(filePath)) {
              return true;
            }
          } catch {
          }
        }
      } catch (error) {
      }
    }
    return false;
  }
  /**
   * Simple glob pattern matching implementation
   * Supports * (any characters) and ? (single character)
   * @param str - String to test
   * @param pattern - Glob pattern
   * @returns True if the string matches the pattern
   */
  static matchesGlobPattern(str2, pattern) {
    let regexPattern = pattern.replace(/\./g, "\\.").replace(/\*\*/g, "###GLOBSTAR###").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]").replace(/###GLOBSTAR###/g, ".*");
    if (!pattern.startsWith("*")) {
      regexPattern = "^" + regexPattern;
    }
    if (!pattern.endsWith("*")) {
      regexPattern = regexPattern + "$";
    }
    try {
      const regex = new RegExp(regexPattern, "i");
      return regex.test(str2);
    } catch (e) {
      return false;
    }
  }
};

// src/commands/generateCommands.ts
var import_obsidian3 = require("obsidian");
function registerGenerateCommands(plugin) {
  plugin.addCommand({
    id: "generate-tags-for-current-note",
    name: "Generate tags for current note",
    icon: "tag",
    editorCallback: async (editor, ctx) => {
      const view = ctx instanceof import_obsidian3.MarkdownView ? ctx : null;
      if (!view?.file) {
        new import_obsidian3.Notice("Open a note");
        return;
      }
      const selectedText = editor.getSelection();
      const content = selectedText || await plugin.app.vault.read(view.file);
      if (!content.trim()) {
        new import_obsidian3.Notice("No content to analyze");
        return;
      }
      const existingTags = TagUtils.getAllTags(plugin.app);
      new import_obsidian3.Notice("Analyzing...");
      try {
        let maxTags = plugin.settings.tagRangeGenerateMax;
        if (plugin.settings.taggingMode === "predefined" /* PredefinedTags */) {
          maxTags = plugin.settings.tagRangePredefinedMax;
        } else if (plugin.settings.taggingMode === "hybrid" /* Hybrid */) {
          maxTags = plugin.settings.tagRangePredefinedMax + plugin.settings.tagRangeGenerateMax;
        }
        const analysis = await plugin.llmService.analyzeTags(
          content,
          existingTags,
          plugin.settings.taggingMode,
          maxTags,
          plugin.settings.language
        );
        const suggestedTags = analysis.suggestedTags;
        const matchedTags = analysis.matchedExistingTags || [];
        const result = await TagUtils.updateNoteTags(plugin.app, view.file, suggestedTags, matchedTags, true, true);
        if (selectedText && result.success) {
          editor.replaceSelection(selectedText);
        }
        plugin.handleTagUpdateResult(result);
      } catch (error) {
        new import_obsidian3.Notice("Failed to generate tags");
      }
    }
  });
  plugin.addCommand({
    id: "generate-tags-for-current-folder",
    name: "Generate tags for current folder",
    icon: "tag",
    callback: async () => {
      const activeFile = plugin.app.workspace.getActiveFile();
      if (!activeFile) {
        new import_obsidian3.Notice("Open a note");
        return;
      }
      const parentFolder = activeFile.parent;
      if (!parentFolder) {
        new import_obsidian3.Notice("No parent folder");
        return;
      }
      const filesInFolder = parentFolder.children.filter((file) => file instanceof import_obsidian3.TFile && file.extension === "md");
      if (filesInFolder.length === 0) {
        new import_obsidian3.Notice("No md files");
        return;
      }
      const confirmed = await plugin.showConfirmationDialog(
        `This will generate tags for ${filesInFolder.length} notes in the current folder. This may take some time.`
      );
      if (!confirmed) {
        new import_obsidian3.Notice("Operation cancelled");
        return;
      }
      await plugin.analyzeAndTagFiles(filesInFolder);
    }
  });
  plugin.addCommand({
    id: "generate-tags-for-vault",
    name: "Generate tags for vault",
    icon: "tag",
    callback: async () => {
      const files = plugin.app.vault.getMarkdownFiles();
      if (files.length === 0) {
        new import_obsidian3.Notice("No md files");
        return;
      }
      const confirmed = await plugin.showConfirmationDialog(
        `This will generate tags for ${files.length} notes in your vault. This may take a long time.`
      );
      if (!confirmed) {
        new import_obsidian3.Notice("Operation cancelled");
        return;
      }
      await plugin.analyzeAndTagFiles(files);
    }
  });
  plugin.registerEvent(
    // @ts-ignore - File menu event is not properly typed in Obsidian API
    plugin.app.workspace.on("file-menu", (menu, file, source, files) => {
      if (files && files.length > 0) {
        const markdownFiles = files.filter((f) => f.extension === "md");
        if (markdownFiles.length > 0) {
          menu.addItem((item) => {
            item.setTitle(`AI tag ${markdownFiles.length} selected notes`).setIcon("tag").onClick(async () => {
              const confirmed = await plugin.showConfirmationDialog(
                `This will generate tags for ${markdownFiles.length} selected notes. This may take some time.`
              );
              if (!confirmed) {
                new import_obsidian3.Notice("Operation cancelled");
                return;
              }
              await plugin.analyzeAndTagFiles(markdownFiles);
            });
          });
        }
      } else if (file.extension === "md") {
        menu.addItem((item) => {
          item.setTitle("AI tag this note").setIcon("tag").onClick(() => plugin.analyzeAndTagFiles([file]));
        });
      }
    })
  );
}

// src/commands/clearCommands.ts
var import_obsidian4 = require("obsidian");
function registerClearCommands(plugin) {
  plugin.addCommand({
    id: "clear-tags-for-current-note",
    name: "Clear tags for current note",
    icon: "eraser",
    editorCallback: (editor, ctx) => {
      const view = ctx instanceof import_obsidian4.MarkdownView ? ctx : null;
      if (view?.file) {
        plugin.clearNoteTags();
      } else {
        new import_obsidian4.Notice("Please open a note first");
      }
    }
  });
  plugin.addCommand({
    id: "clear-tags-for-current-folder",
    name: "Clear tags for current folder",
    icon: "eraser",
    callback: async () => {
      const activeFile = plugin.app.workspace.getActiveFile();
      if (!activeFile) {
        new import_obsidian4.Notice("Please open a note first");
        return;
      }
      const parentPath = activeFile.parent?.path ?? "";
      const allFiles = plugin.app.vault.getMarkdownFiles();
      const filesInFolder = allFiles.filter((file) => {
        const filePath = file.parent?.path ?? "";
        return filePath === parentPath;
      });
      if (filesInFolder.length === 0) {
        new import_obsidian4.Notice("No markdown files found in current folder");
        return;
      }
      const confirmed = await plugin.showConfirmationDialog(
        `Remove all tags from ${filesInFolder.length} notes in this folder? This cannot be undone.`
      );
      if (!confirmed) {
        new import_obsidian4.Notice("Operation cancelled");
        return;
      }
      const result = await plugin.clearDirectoryTags(filesInFolder);
      if (result.success) {
        new import_obsidian4.Notice(`Tags cleared from ${result.successCount} notes`);
      } else {
        new import_obsidian4.Notice("Failed to clear tags");
      }
    }
  });
  plugin.addCommand({
    id: "clear-tags-for-vault",
    name: "Clear tags for vault",
    icon: "eraser",
    callback: async () => {
      await plugin.clearAllNotesTags();
    }
  });
}

// src/commands/predefinedTagsCommands.ts
var import_obsidian5 = require("obsidian");
function registerPredefinedTagsCommands(plugin) {
  plugin.addCommand({
    id: "assign-predefined-tags-for-current-note",
    name: "Assign predefined tags for current note",
    icon: "tag",
    editorCallback: async (editor, ctx) => {
      const view = ctx instanceof import_obsidian5.MarkdownView ? ctx : null;
      if (!view?.file) {
        new import_obsidian5.Notice("No active file");
        return;
      }
      if (!plugin.settings.predefinedTagsPath) {
        new import_obsidian5.Notice("Set tags file");
        return;
      }
      try {
        const tagsContent = await plugin.app.vault.adapter.read(plugin.settings.predefinedTagsPath);
        const predefinedTags = tagsContent.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
        if (predefinedTags.length === 0) {
          new import_obsidian5.Notice("No tags in file");
          return;
        }
        const content = await plugin.app.vault.read(view?.file);
        const analysis = await plugin.llmService.analyzeTags(content, predefinedTags, "predefined" /* PredefinedTags */, plugin.settings.tagRangePredefinedMax);
        const matchedTags = analysis.matchedExistingTags || [];
        if (matchedTags.length === 0) {
          new import_obsidian5.Notice("No matching tags");
          return;
        }
        const result = await TagUtils.updateNoteTags(plugin.app, view.file, [], matchedTags, false, true);
        plugin.handleTagUpdateResult(result);
      } catch (error) {
        new import_obsidian5.Notice("Assign failed");
      }
    }
  });
  plugin.addCommand({
    id: "assign-predefined-tags-for-current-folder",
    name: "Assign predefined tags for current folder",
    icon: "tag",
    callback: async () => {
      const activeFile = plugin.app.workspace.getActiveFile();
      if (!activeFile) {
        new import_obsidian5.Notice("Open a note");
        return;
      }
      const parentFolder = activeFile.parent;
      if (!parentFolder) {
        new import_obsidian5.Notice("No parent folder");
        return;
      }
      if (!plugin.settings.predefinedTagsPath) {
        new import_obsidian5.Notice("Set tags file");
        return;
      }
      const filesInFolder = parentFolder.children.filter((file) => file instanceof import_obsidian5.TFile && file.extension === "md");
      if (filesInFolder.length === 0) {
        new import_obsidian5.Notice("No md files");
        return;
      }
      try {
        const tagsContent = await plugin.app.vault.adapter.read(plugin.settings.predefinedTagsPath);
        const predefinedTags = tagsContent.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
        if (predefinedTags.length === 0) {
          new import_obsidian5.Notice("No predefined tags found in the file");
          return;
        }
        const confirmed = await plugin.showConfirmationDialog(
          `This will assign predefined tags to ${filesInFolder.length} notes in the current folder. This may take some time.`
        );
        if (!confirmed) {
          new import_obsidian5.Notice("Operation cancelled");
          return;
        }
        new import_obsidian5.Notice(`Assigning predefined tags to ${filesInFolder.length} notes in the current folder...`);
        let processedCount = 0;
        let successCount = 0;
        let lastNoticeTime = Date.now();
        for (const file of filesInFolder) {
          try {
            const content = await plugin.app.vault.read(file);
            if (!content.trim())
              continue;
            const analysis = await plugin.llmService.analyzeTags(content, predefinedTags, "predefined" /* PredefinedTags */, plugin.settings.tagRangePredefinedMax);
            const matchedTags = analysis.matchedExistingTags || [];
            const result = await TagUtils.updateNoteTags(plugin.app, file, [], matchedTags, false, true);
            if (result.success) {
              successCount++;
            }
            processedCount++;
            const currentTime = Date.now();
            if (currentTime - lastNoticeTime >= 15e3 || processedCount === filesInFolder.length) {
              new import_obsidian5.Notice(`Progress: ${processedCount}/${filesInFolder.length}`);
              lastNoticeTime = currentTime;
            }
          } catch (error) {
          }
        }
        new import_obsidian5.Notice(`Completed: ${successCount}/${filesInFolder.length}`);
      } catch (error) {
        new import_obsidian5.Notice("Failed to assign predefined tags to notes in current folder");
      }
    }
  });
  plugin.addCommand({
    id: "assign-predefined-tags-for-vault",
    name: "Assign predefined tags for vault",
    icon: "tag",
    callback: async () => {
      if (!plugin.settings.predefinedTagsPath) {
        new import_obsidian5.Notice("Set tags file");
        return;
      }
      const files = plugin.app.vault.getMarkdownFiles();
      if (files.length === 0) {
        new import_obsidian5.Notice("No md files");
        return;
      }
      try {
        const tagsContent = await plugin.app.vault.adapter.read(plugin.settings.predefinedTagsPath);
        const predefinedTags = tagsContent.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
        if (predefinedTags.length === 0) {
          new import_obsidian5.Notice("No predefined tags found in the file");
          return;
        }
        const confirmed = await plugin.showConfirmationDialog(
          `This will assign predefined tags to ${files.length} notes in your vault. This may take a long time.`
        );
        if (!confirmed) {
          new import_obsidian5.Notice("Operation cancelled");
          return;
        }
        new import_obsidian5.Notice(`Assigning predefined tags to ${files.length} notes in your vault...`);
        let processedCount = 0;
        let successCount = 0;
        let lastNoticeTime = Date.now();
        for (const file of files) {
          try {
            const content = await plugin.app.vault.read(file);
            if (!content.trim())
              continue;
            const analysis = await plugin.llmService.analyzeTags(content, predefinedTags, "predefined" /* PredefinedTags */, plugin.settings.tagRangePredefinedMax);
            const matchedTags = analysis.matchedExistingTags || [];
            const result = await TagUtils.updateNoteTags(plugin.app, file, [], matchedTags, false, true);
            if (result.success) {
              successCount++;
            }
            processedCount++;
            const currentTime = Date.now();
            if (currentTime - lastNoticeTime >= 15e3 || processedCount === files.length) {
              new import_obsidian5.Notice(`Progress: ${processedCount}/${files.length}`);
              lastNoticeTime = currentTime;
            }
          } catch (error) {
          }
        }
        new import_obsidian5.Notice(`Completed: ${successCount}/${files.length}`);
      } catch (error) {
        new import_obsidian5.Notice("Failed to assign predefined tags to notes");
      }
    }
  });
}

// src/commands/utilityCommands.ts
function registerUtilityCommands(plugin) {
  plugin.addCommand({
    id: "collect-all-tags",
    name: "Collect all tags from vault",
    icon: "tags",
    callback: async () => {
      await TagUtils.saveAllTags(plugin.app, plugin.settings.tagDir);
    }
  });
  plugin.addCommand({
    id: "show-tag-network",
    name: "Show tag network visualization",
    icon: "graph",
    callback: async () => {
      await plugin.showTagNetwork();
    }
  });
}

// src/commands/index.ts
function registerCommands(plugin) {
  registerGenerateCommands(plugin);
  registerClearCommands(plugin);
  registerPredefinedTagsCommands(plugin);
  registerUtilityCommands(plugin);
}

// src/core/settings.ts
var DEFAULT_SETTINGS = {
  serviceType: "cloud",
  localEndpoint: "http://localhost:11434/v1/chat/completions",
  localModel: "mistral",
  cloudEndpoint: "https://api.openai.com/v1/chat/completions",
  cloudApiKey: "",
  cloudModel: "gpt-4",
  cloudServiceType: "openai",
  taggingMode: "generate" /* GenerateNew */,
  excludedFolders: [],
  language: "default",
  predefinedTagsPath: "",
  tagSourceType: "vault",
  tagDir: "",
  tagRangeMatchMax: 5,
  tagRangeGenerateMax: 5,
  tagRangePredefinedMax: 5,
  replaceTags: true
};

// src/ui/settings/AITaggerSettingTab.ts
var import_obsidian11 = require("obsidian");

// src/ui/settings/LLMSettingsSection.ts
var import_obsidian6 = require("obsidian");

// src/ui/settings/BaseSettingSection.ts
var BaseSettingSection = class {
  plugin;
  containerEl;
  settingTab;
  constructor(plugin, containerEl, settingTab) {
    this.plugin = plugin;
    this.containerEl = containerEl;
    this.settingTab = settingTab;
  }
};

// src/ui/settings/LLMSettingsSection.ts
var LLMSettingsSection = class extends BaseSettingSection {
  statusContainer = null;
  statusEl = null;
  display() {
    this.containerEl.createEl("h1", { text: "LLM settings" });
    this.createServiceTypeDropdown();
    this.plugin.settings.serviceType === "local" ? this.displayLocalSettings() : this.displayCloudSettings();
    if (this.plugin.settings.serviceType === "local") {
      this.checkLocalService(this.plugin.settings.localEndpoint);
    }
  }
  createServiceTypeDropdown() {
    if (!this.plugin.settings.serviceType) {
      this.plugin.settings.serviceType = "cloud";
    }
    new import_obsidian6.Setting(this.containerEl).setName("Service type").setDesc("Choose the AI service provider to use").addDropdown(
      (dropdown) => dropdown.addOptions({
        "local": "Local LLM",
        "cloud": "Cloud service"
      }).setValue(this.plugin.settings.serviceType).onChange(async (value) => {
        this.plugin.settings.serviceType = value;
        await this.plugin.saveSettings();
        this.settingTab.display();
      })
    );
    if (this.plugin.settings.serviceType === "cloud") {
      new import_obsidian6.Setting(this.containerEl).setName("Cloud provider").setDesc("Select the cloud service provider").addDropdown(
        (dropdown) => dropdown.addOptions({
          "openai": "OpenAI",
          "gemini": "Google Gemini",
          "deepseek": "DeepSeek",
          "aliyun": "Aliyun",
          "claude": "Anthropic Claude",
          "groq": "Groq LLM",
          "vertex": "Google Vertex AI",
          "openrouter": "OpenRouter",
          "bedrock": "AWS Bedrock",
          "requesty": "Requesty",
          "cohere": "Cohere",
          "grok": "Grok",
          "mistral": "Mistral AI",
          "openai-compatible": "OpenAI Compatible"
        }).setValue(this.plugin.settings.cloudServiceType).onChange(async (value) => {
          const type2 = value;
          this.plugin.settings.cloudServiceType = type2;
          try {
            const endpoints14 = await Promise.resolve().then(() => __toESM(require_cloudEndpoints()));
            switch (type2) {
              case "openai":
                this.plugin.settings.cloudEndpoint = endpoints14.openai;
                this.plugin.settings.cloudModel = "gpt-3.5-turbo";
                break;
              case "gemini":
                this.plugin.settings.cloudEndpoint = endpoints14.gemini;
                this.plugin.settings.cloudModel = "gemini-2.0-flash";
                break;
              case "deepseek":
                this.plugin.settings.cloudEndpoint = endpoints14.deepseek;
                this.plugin.settings.cloudModel = "deepseek-chat";
                break;
              case "aliyun":
                this.plugin.settings.cloudEndpoint = endpoints14.aliyun;
                this.plugin.settings.cloudModel = "qwen-max";
                break;
              case "claude":
                this.plugin.settings.cloudEndpoint = endpoints14.claude;
                this.plugin.settings.cloudModel = "claude-3-opus-20240229";
                break;
              case "groq":
                this.plugin.settings.cloudEndpoint = endpoints14.groq;
                this.plugin.settings.cloudModel = "mixtral-8x7b-32768";
                break;
              case "vertex":
                this.plugin.settings.cloudEndpoint = endpoints14.vertex;
                this.plugin.settings.cloudModel = "gemini-2.0-flash";
                break;
              case "openrouter":
                this.plugin.settings.cloudEndpoint = endpoints14.openrouter;
                this.plugin.settings.cloudModel = "default";
                break;
              case "bedrock":
                this.plugin.settings.cloudEndpoint = endpoints14.bedrock;
                this.plugin.settings.cloudModel = "anthropic.claude-v2";
                break;
              case "requesty":
                this.plugin.settings.cloudEndpoint = endpoints14.requesty;
                this.plugin.settings.cloudModel = "gpt-4";
                break;
              case "cohere":
                this.plugin.settings.cloudEndpoint = endpoints14.cohere;
                this.plugin.settings.cloudModel = "command";
                break;
              case "grok":
                this.plugin.settings.cloudEndpoint = endpoints14.grok;
                this.plugin.settings.cloudModel = "grok-1";
                break;
              case "mistral":
                this.plugin.settings.cloudEndpoint = endpoints14.mistral;
                this.plugin.settings.cloudModel = "mistral-medium";
                break;
              case "openai-compatible":
                this.plugin.settings.cloudEndpoint = "http://your-api-endpoint/v1/chat/completions";
                this.plugin.settings.cloudModel = "your-model";
                break;
            }
            await this.plugin.saveSettings();
            this.settingTab.display();
          } catch (error) {
            new import_obsidian6.Notice("Failed to load cloud endpoints");
          }
        })
      );
    }
  }
  displayLocalSettings() {
    new import_obsidian6.Setting(this.containerEl).setName("Local llm endpoint").setDesc("Enter the base URL for your local service").addText((text) => text.setPlaceholder("http://localhost:11434/v1/chat/completions").setValue(this.plugin.settings.localEndpoint).onChange(async (value) => {
      this.plugin.settings.localEndpoint = value;
      await this.plugin.saveSettings();
      this.settingTab.display();
    }));
    new import_obsidian6.Setting(this.containerEl).setName("Model name").setDesc("Name of the model to use with your local service").addText((text) => text.setPlaceholder("Model name (e.g., mistral, llama2, gpt-3.5-turbo)").setValue(this.plugin.settings.localModel).onChange(async (value) => {
      this.plugin.settings.localModel = value;
      await this.plugin.saveSettings();
    }));
    const tipsEl = this.containerEl.createEl("div", {
      cls: "ai-tagger-tips-block"
    });
    tipsEl.createEl("h3", { text: "Tips: Popular Local LLM Tools" });
    const tipsList = tipsEl.createEl("ul");
    tipsList.createEl("li", { text: "Ollama: http://localhost:11434/v1/chat/completions" });
    tipsList.createEl("li", { text: "LocalAI: http://localhost:8080/v1/chat/completions" });
    tipsList.createEl("li", { text: "LM Studio: http://localhost:1234/v1/chat/completions" });
    tipsList.createEl("li", { text: "Jan: http://localhost:1337/v1/chat/completions" });
    tipsList.createEl("li", { text: "KoboldCPP: http://localhost:5001/v1/chat/completions" });
    tipsEl.style.backgroundColor = "rgba(100, 100, 100, 0.1)";
    tipsEl.style.padding = "8px 12px";
    tipsEl.style.borderRadius = "4px";
    tipsEl.style.marginBottom = "16px";
    tipsEl.style.fontSize = "0.9em";
    this.createTestButton();
  }
  createTestButton() {
    const testContainer = this.containerEl.createDiv("connection-test-container");
    const testSetting = new import_obsidian6.Setting(testContainer).setName("Connection test").setDesc("Test connection to AI service");
    const buttonContainer = testSetting.settingEl.createDiv("setting-item-control");
    const button = new import_obsidian6.ButtonComponent(buttonContainer).setButtonText("Test connection").onClick(async () => {
      button.setButtonText("Testing...");
      button.setDisabled(true);
      if (this.statusContainer) {
        this.statusContainer.style.display = "block";
        this.statusEl.textContent = "";
        this.statusEl.className = "";
      }
      try {
        const testResult = await this.plugin.llmService.testConnection();
        if (testResult.result === "success" /* Success */) {
          this.setStatusMessage("Connection successful!", "success");
        } else {
          this.setStatusMessage(`Connection failed: ${testResult.error?.message || "Unknown error"}`, "error");
        }
      } catch (error) {
        this.setStatusMessage(`Error: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
      } finally {
        button.setButtonText("Test connection");
        button.setDisabled(false);
      }
    });
    this.statusContainer = testContainer.createDiv("connection-test-status");
    this.statusEl = this.statusContainer.createSpan();
    if (this.statusContainer) {
      this.statusContainer.style.display = "none";
    }
  }
  displayCloudSettings() {
    new import_obsidian6.Setting(this.containerEl).setName("API endpoint").setDesc("Enter the complete chat completions API endpoint URL").addText((text) => {
      const placeholder = this.plugin.settings.cloudEndpoint || (this.plugin.settings.cloudServiceType === "openai-compatible" ? "http://your-api-endpoint/v1/chat/completions" : "");
      text.setPlaceholder(placeholder).setValue(this.plugin.settings.cloudEndpoint);
      text.onChange(async (value) => {
        this.plugin.settings.cloudEndpoint = value;
        await this.plugin.saveSettings();
      });
      return text;
    });
    new import_obsidian6.Setting(this.containerEl).setName("API key").setDesc("Cloud service API key").addText((text) => text.setPlaceholder(
      this.plugin.settings.cloudServiceType === "openai" ? "sk-..." : this.plugin.settings.cloudServiceType === "gemini" ? "AIza..." : this.plugin.settings.cloudServiceType === "deepseek" ? "deepseek-..." : this.plugin.settings.cloudServiceType === "aliyun" ? "sk-..." : this.plugin.settings.cloudServiceType === "claude" ? "sk-ant-..." : this.plugin.settings.cloudServiceType === "groq" ? "gsk_..." : this.plugin.settings.cloudServiceType === "openrouter" ? "sk-or-..." : this.plugin.settings.cloudServiceType === "bedrock" ? "aws-credentials" : this.plugin.settings.cloudServiceType === "requesty" ? "rq-..." : this.plugin.settings.cloudServiceType === "cohere" ? "co-..." : this.plugin.settings.cloudServiceType === "grok" ? "grok-..." : this.plugin.settings.cloudServiceType === "mistral" ? "mist-..." : this.plugin.settings.cloudServiceType === "openai-compatible" ? "your-api-key" : "Bearer oauth2-token"
    ).setValue(this.plugin.settings.cloudApiKey).onChange(async (value) => {
      this.plugin.settings.cloudApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(this.containerEl).setName("Model name").setDesc("Name of model to use").addText((text) => text.setPlaceholder(
      this.plugin.settings.cloudServiceType === "openai" ? "gpt-3.5-turbo" : this.plugin.settings.cloudServiceType === "gemini" ? "gemini-pro" : this.plugin.settings.cloudServiceType === "deepseek" ? "deepseek-chat" : this.plugin.settings.cloudServiceType === "aliyun" ? "qwen-max" : this.plugin.settings.cloudServiceType === "claude" ? "claude-3-opus-20240229" : this.plugin.settings.cloudServiceType === "groq" ? "mixtral-8x7b-32768" : this.plugin.settings.cloudServiceType === "openrouter" ? "default" : this.plugin.settings.cloudServiceType === "bedrock" ? "anthropic.claude-v2" : this.plugin.settings.cloudServiceType === "requesty" ? "gpt-4" : this.plugin.settings.cloudServiceType === "cohere" ? "command" : this.plugin.settings.cloudServiceType === "grok" ? "grok-1" : this.plugin.settings.cloudServiceType === "mistral" ? "mistral-medium" : this.plugin.settings.cloudServiceType === "openai-compatible" ? "your-model" : "gemini-pro"
    ).setValue(this.plugin.settings.cloudModel).onChange(async (value) => {
      this.plugin.settings.cloudModel = value;
      await this.plugin.saveSettings();
    }));
    this.createTestButton();
  }
  setStatusMessage(message, status) {
    if (!this.statusContainer || !this.statusEl)
      return;
    this.statusContainer.style.display = "block";
    this.statusContainer.className = "connection-test-status " + status;
    this.statusEl.textContent = message;
  }
  async checkLocalService(endpoint) {
    const baseUrl = endpoint.trim().replace(/\/$/, "").replace(/\/v1\/chat\/completions$/, "");
    let checkUrl = `${baseUrl}/v1/models`;
    try {
      const response = await fetch(checkUrl, {
        method: "GET",
        headers: { "Content-Type": "application/json" }
      });
      if (!response.ok) {
        new import_obsidian6.Notice(`Local LLM service does not appear to be running. Please check your endpoint URL.`, 1e4);
      }
    } catch (error) {
      new import_obsidian6.Notice(`Local LLM service is not available. Please make sure it is installed and running on the correct port.`, 1e4);
    }
  }
};

// src/ui/settings/TaggingSettingsSection.ts
var import_obsidian9 = require("obsidian");

// src/ui/modals/ExcludedFilesModal.ts
var import_obsidian8 = require("obsidian");

// src/utils/vaultPathFetcher.ts
var import_obsidian7 = require("obsidian");
function getVaultItems(app, searchTerm) {
  const allItems = [];
  collectAllPaths(app, allItems);
  if (searchTerm && searchTerm.trim()) {
    const term = searchTerm.trim().toLowerCase();
    const filteredItems = allItems.filter(
      (item) => item.path.toLowerCase().includes(term) || item.name.toLowerCase().includes(term)
    );
    return filteredItems;
  }
  return allItems;
}
function collectAllPaths(app, result) {
  const rootFolder = app.vault.getRoot();
  const files = app.vault.getFiles();
  const folders = getAllFolders(app);
  for (const folder of folders) {
    if (folder.path === "/")
      continue;
    result.push({
      path: folder.path.endsWith("/") ? folder.path : folder.path + "/",
      isFolder: true,
      name: folder.name
    });
  }
  for (const file of files) {
    result.push({
      path: file.path,
      isFolder: false,
      name: file.name
    });
  }
}
function getAllFolders(app) {
  const result = [];
  const rootFolder = app.vault.getRoot();
  function collectFolders(folder) {
    result.push(folder);
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFolder) {
        collectFolders(child);
      }
    }
  }
  collectFolders(rootFolder);
  return result;
}

// src/ui/modals/ExcludedFilesModal.ts
var ExcludedFilesModal = class extends import_obsidian8.Modal {
  constructor(app, plugin, onSave) {
    super(app);
    this.plugin = plugin;
    this.onSave = onSave;
    this.excludedFolders = [...plugin.settings.excludedFolders];
  }
  excludedFolders = [];
  filterInput;
  pathDropdownContainer;
  searchTerm = "";
  cachedPaths = [];
  hasLoadedPaths = false;
  documentClickListener = (event) => {
    const target = event.target;
    if (this.filterInput && !this.filterInput.parentElement?.contains(target) && !this.pathDropdownContainer.contains(target)) {
      this.pathDropdownContainer.style.display = "none";
    }
  };
  loadCachedPaths() {
    if (!this.hasLoadedPaths) {
      try {
        this.cachedPaths = getVaultItems(this.app);
        this.hasLoadedPaths = true;
      } catch (error) {
        this.cachedPaths = [];
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    this.loadCachedPaths();
    contentEl.addClass("excluded-files-modal");
    contentEl.style.padding = "20px";
    contentEl.style.maxWidth = "500px";
    contentEl.style.margin = "0 auto";
    const titleEl = contentEl.createEl("h2", {
      text: "Excluded files",
      cls: "excluded-files-title"
    });
    titleEl.style.marginTop = "0";
    titleEl.style.marginBottom = "10px";
    titleEl.style.color = "var(--text-normal)";
    titleEl.style.borderBottom = "1px solid var(--background-modifier-border)";
    titleEl.style.paddingBottom = "10px";
    const subtitleEl = contentEl.createEl("p", {
      text: "Files matching the following filters are currently excluded:",
      cls: "excluded-files-subtitle"
    });
    subtitleEl.style.margin = "10px 0 15px";
    subtitleEl.style.color = "var(--text-muted)";
    subtitleEl.style.fontSize = "14px";
    const excludedListContainer = contentEl.createDiv({ cls: "excluded-list" });
    excludedListContainer.style.marginBottom = "20px";
    excludedListContainer.style.maxHeight = "200px";
    excludedListContainer.style.overflowY = "auto";
    excludedListContainer.style.padding = "5px";
    excludedListContainer.style.border = "1px solid var(--background-modifier-border)";
    excludedListContainer.style.borderRadius = "4px";
    excludedListContainer.style.backgroundColor = "var(--background-secondary)";
    this.renderExcludedList(excludedListContainer);
    const filterContainer = contentEl.createDiv({
      cls: "filter-container"
    });
    filterContainer.style.marginBottom = "20px";
    const filterLabel = filterContainer.createEl("div", {
      text: "Filter",
      cls: "filter-label"
    });
    filterLabel.style.fontWeight = "bold";
    filterLabel.style.marginBottom = "8px";
    filterLabel.style.fontSize = "16px";
    const inputContainer = filterContainer.createDiv({
      cls: "filter-input-container"
    });
    inputContainer.style.display = "flex";
    inputContainer.style.position = "relative";
    this.filterInput = inputContainer.createEl("input", {
      type: "text",
      placeholder: 'Enter path or "/regex/"',
      cls: "filter-input",
      value: ""
    });
    this.filterInput.style.flex = "1";
    this.filterInput.style.padding = "8px 12px";
    this.filterInput.style.fontSize = "14px";
    this.filterInput.style.border = "1px solid var(--background-modifier-border)";
    this.filterInput.style.borderRadius = "4px";
    this.filterInput.style.backgroundColor = "var(--background-primary)";
    this.searchTerm = "";
    this.pathDropdownContainer = inputContainer.createDiv({
      cls: "path-dropdown-container"
    });
    this.pathDropdownContainer.style.position = "absolute";
    this.pathDropdownContainer.style.top = "100%";
    this.pathDropdownContainer.style.left = "0";
    this.pathDropdownContainer.style.width = "100%";
    this.pathDropdownContainer.style.maxHeight = "200px";
    this.pathDropdownContainer.style.overflowY = "auto";
    this.pathDropdownContainer.style.backgroundColor = "var(--background-primary)";
    this.pathDropdownContainer.style.border = "1px solid var(--background-modifier-border)";
    this.pathDropdownContainer.style.borderRadius = "4px";
    this.pathDropdownContainer.style.boxShadow = "0 4px 14px rgba(0, 0, 0, 0.15)";
    this.pathDropdownContainer.style.zIndex = "1000";
    this.pathDropdownContainer.style.display = "none";
    this.pathDropdownContainer.addEventListener("click", (e) => {
      e.stopPropagation();
    });
    const addButtonContainer = inputContainer.createDiv();
    addButtonContainer.style.marginLeft = "8px";
    const addButtonEl = new import_obsidian8.ButtonComponent(addButtonContainer).setButtonText("Add").onClick(() => {
      const value = this.filterInput.value.trim();
      if (value && !this.excludedFolders.includes(value)) {
        this.excludedFolders.push(value);
        this.renderExcludedList(excludedListContainer);
        this.filterInput.value = "";
        this.searchTerm = "";
        this.pathDropdownContainer.style.display = "none";
      }
    });
    addButtonEl.buttonEl.addClass("excluded-files-add-button");
    addButtonEl.buttonEl.style.padding = "8px 16px";
    addButtonEl.buttonEl.style.fontSize = "14px";
    addButtonEl.buttonEl.style.fontWeight = "bold";
    this.filterInput.addEventListener("focus", () => {
      this.updatePathDropdown(this.filterInput.value);
      this.pathDropdownContainer.style.display = "block";
    });
    this.filterInput.addEventListener("input", () => {
      this.searchTerm = this.filterInput.value;
      this.updatePathDropdown(this.searchTerm);
      this.pathDropdownContainer.style.display = "block";
    });
    this.filterInput.addEventListener("click", (e) => {
      e.stopPropagation();
      this.updatePathDropdown(this.filterInput.value);
      this.pathDropdownContainer.style.display = "block";
    });
    document.addEventListener("click", this.documentClickListener);
    const spacerEl = contentEl.createDiv("modal-spacer");
    spacerEl.style.flexGrow = "1";
    spacerEl.style.minHeight = "20px";
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "space-between";
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.padding = "10px 0";
    buttonContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    const leftButtonContainer = buttonContainer.createDiv("left-buttons");
    const clearAllButtonEl = new import_obsidian8.ButtonComponent(leftButtonContainer).setButtonText("Clear All").onClick(() => {
      if (this.excludedFolders.length > 0 && confirm("Are you sure you want to remove all excluded paths?")) {
        this.excludedFolders = [];
        this.renderExcludedList(excludedListContainer);
      }
    });
    clearAllButtonEl.buttonEl.addClass("excluded-files-clear-button");
    clearAllButtonEl.buttonEl.style.backgroundColor = "var(--background-secondary)";
    if (this.excludedFolders.length === 0) {
      clearAllButtonEl.buttonEl.setAttribute("disabled", "true");
      clearAllButtonEl.buttonEl.addClass("disabled");
    }
    const rightButtonContainer = buttonContainer.createDiv("right-buttons");
    rightButtonContainer.style.display = "flex";
    rightButtonContainer.style.gap = "10px";
    const cancelButtonEl = new import_obsidian8.ButtonComponent(rightButtonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
    });
    cancelButtonEl.buttonEl.style.minWidth = "80px";
    const saveButtonEl = new import_obsidian8.ButtonComponent(rightButtonContainer).setButtonText("Save").setCta().onClick(() => {
      this.onSave(this.excludedFolders);
      this.close();
    });
    saveButtonEl.buttonEl.style.minWidth = "80px";
  }
  updatePathDropdown(searchTerm) {
    this.pathDropdownContainer.empty();
    try {
      if (!this.hasLoadedPaths) {
        this.loadCachedPaths();
      }
      const lowerSearchTerm = searchTerm.toLowerCase().trim();
      let matchedItems = [];
      if (lowerSearchTerm) {
        matchedItems = this.cachedPaths.filter(
          (item) => item.path.toLowerCase().includes(lowerSearchTerm) || item.name.toLowerCase().includes(lowerSearchTerm)
        );
        matchedItems.sort((a, b) => {
          const aName = a.name.toLowerCase();
          const bName = b.name.toLowerCase();
          const aPath = a.path.toLowerCase();
          const bPath = b.path.toLowerCase();
          if (aName === lowerSearchTerm && bName !== lowerSearchTerm)
            return -1;
          if (aName !== lowerSearchTerm && bName === lowerSearchTerm)
            return 1;
          if (aName.startsWith(lowerSearchTerm) && !bName.startsWith(lowerSearchTerm))
            return -1;
          if (!aName.startsWith(lowerSearchTerm) && bName.startsWith(lowerSearchTerm))
            return 1;
          if (aPath.startsWith(lowerSearchTerm) && !bPath.startsWith(lowerSearchTerm))
            return -1;
          if (!aPath.startsWith(lowerSearchTerm) && bPath.startsWith(lowerSearchTerm))
            return 1;
          if (a.isFolder && !b.isFolder)
            return -1;
          if (!a.isFolder && b.isFolder)
            return 1;
          return aPath.localeCompare(bPath);
        });
      } else {
        const commonPatterns = [
          { path: "Tags/", isFolder: true, name: "Tags" },
          { path: "images/", isFolder: true, name: "images" },
          { path: "audio/", isFolder: true, name: "audio" },
          { path: "Excalidraw/", isFolder: true, name: "Excalidraw" },
          { path: "textgenerator/", isFolder: true, name: "textgenerator" },
          { path: "attachments/", isFolder: true, name: "attachments" },
          { path: "templates/", isFolder: true, name: "templates" },
          { path: ".obsidian/", isFolder: true, name: ".obsidian" }
        ];
        for (const pattern of commonPatterns) {
          const existingItem = this.cachedPaths.find(
            (item) => item.path.toLowerCase() === pattern.path.toLowerCase() || item.name.toLowerCase() === pattern.name.toLowerCase()
          );
          if (existingItem) {
            matchedItems.push(existingItem);
          } else {
            matchedItems.push(pattern);
          }
        }
      }
      const limitedItems = matchedItems.slice(0, 10);
      if (limitedItems.length === 0) {
        const noItemsEl = this.pathDropdownContainer.createDiv({
          cls: "path-dropdown-empty"
        });
        noItemsEl.style.padding = "10px";
        noItemsEl.style.textAlign = "center";
        noItemsEl.style.color = "var(--text-muted)";
        noItemsEl.style.fontSize = "14px";
        noItemsEl.textContent = "No matching paths found";
        if (lowerSearchTerm) {
          const useCurrentTextEl = this.pathDropdownContainer.createDiv({
            cls: "path-dropdown-item path-use-current"
          });
          useCurrentTextEl.style.padding = "8px 12px";
          useCurrentTextEl.style.cursor = "pointer";
          useCurrentTextEl.style.display = "flex";
          useCurrentTextEl.style.alignItems = "center";
          useCurrentTextEl.style.color = "var(--text-accent)";
          useCurrentTextEl.style.backgroundColor = "var(--background-secondary)";
          useCurrentTextEl.style.borderRadius = "4px";
          useCurrentTextEl.style.margin = "8px";
          useCurrentTextEl.addEventListener("mouseenter", () => {
            useCurrentTextEl.style.backgroundColor = "var(--background-modifier-hover)";
          });
          useCurrentTextEl.addEventListener("mouseleave", () => {
            useCurrentTextEl.style.backgroundColor = "var(--background-secondary)";
          });
          useCurrentTextEl.textContent = `Use "${searchTerm}" as pattern`;
          useCurrentTextEl.addEventListener("click", () => {
            if (!this.excludedFolders.includes(searchTerm)) {
              this.excludedFolders.push(searchTerm);
              const listContainer = this.contentEl.querySelector(".excluded-list");
              if (listContainer)
                this.renderExcludedList(listContainer);
              this.filterInput.value = "";
              this.searchTerm = "";
              this.pathDropdownContainer.style.display = "none";
            }
          });
        }
      } else {
        for (const item of limitedItems) {
          this.renderPathItem(item);
        }
        if (matchedItems.length > limitedItems.length) {
          const moreItemsEl = this.pathDropdownContainer.createDiv({
            cls: "path-dropdown-more"
          });
          moreItemsEl.style.padding = "6px 10px";
          moreItemsEl.style.textAlign = "center";
          moreItemsEl.style.fontSize = "12px";
          moreItemsEl.style.color = "var(--text-muted)";
          moreItemsEl.style.borderTop = "1px solid var(--background-modifier-border)";
          moreItemsEl.textContent = `${matchedItems.length - limitedItems.length} more results...`;
        }
      }
      this.pathDropdownContainer.style.display = "block";
    } catch (error) {
      const errorEl = this.pathDropdownContainer.createDiv({
        cls: "path-dropdown-error"
      });
      errorEl.style.padding = "10px";
      errorEl.style.color = "var(--text-error)";
      errorEl.textContent = "Error loading paths";
    }
  }
  renderPathItem(item) {
    const itemEl = this.pathDropdownContainer.createDiv({
      cls: "path-dropdown-item"
    });
    itemEl.style.padding = "8px 12px";
    itemEl.style.cursor = "pointer";
    itemEl.style.display = "flex";
    itemEl.style.alignItems = "center";
    itemEl.style.borderBottom = "1px solid var(--background-modifier-border)";
    itemEl.addEventListener("mouseenter", () => {
      itemEl.style.backgroundColor = "var(--background-modifier-hover)";
    });
    itemEl.addEventListener("mouseleave", () => {
      itemEl.style.backgroundColor = "";
    });
    const iconEl = itemEl.createSpan({
      cls: `path-item-icon ${item.isFolder ? "folder-icon" : "file-icon"}`
    });
    iconEl.style.marginRight = "8px";
    iconEl.style.fontSize = "14px";
    iconEl.style.minWidth = "20px";
    iconEl.style.display = "inline-flex";
    iconEl.style.alignItems = "center";
    iconEl.style.justifyContent = "center";
    const textEl = itemEl.createSpan({
      cls: "path-item-text",
      text: item.path
    });
    textEl.style.overflow = "hidden";
    textEl.style.textOverflow = "ellipsis";
    textEl.style.whiteSpace = "nowrap";
    textEl.style.flex = "1";
    if (this.searchTerm) {
      const searchTermLower = this.searchTerm.toLowerCase();
      const pathLower = item.path.toLowerCase();
      const index = pathLower.indexOf(searchTermLower);
      if (index >= 0) {
        textEl.empty();
        if (index > 0) {
          textEl.createSpan({
            text: item.path.substring(0, index)
          });
        }
        const highlightSpan = textEl.createSpan({
          text: item.path.substring(index, index + this.searchTerm.length),
          cls: "path-match-highlight"
        });
        highlightSpan.style.backgroundColor = "var(--text-highlight-bg)";
        highlightSpan.style.borderRadius = "2px";
        if (index + this.searchTerm.length < item.path.length) {
          textEl.createSpan({
            text: item.path.substring(index + this.searchTerm.length)
          });
        }
      }
    }
    itemEl.addEventListener("click", () => {
      this.filterInput.value = item.path;
      this.searchTerm = item.path;
      this.pathDropdownContainer.style.display = "none";
      if (!this.excludedFolders.includes(item.path)) {
        this.excludedFolders.push(item.path);
        const listContainer = this.contentEl.querySelector(".excluded-list");
        if (listContainer)
          this.renderExcludedList(listContainer);
        this.filterInput.value = "";
        this.searchTerm = "";
      }
    });
  }
  renderExcludedList(container) {
    container.empty();
    if (this.excludedFolders.length === 0) {
      const emptyEl = container.createEl("div", {
        text: "No exclusions defined yet.",
        cls: "excluded-empty-message"
      });
      emptyEl.style.padding = "10px";
      emptyEl.style.color = "var(--text-muted)";
      emptyEl.style.textAlign = "center";
      emptyEl.style.fontStyle = "italic";
      return;
    }
    const excludedList = container.createEl("div", {
      cls: "excluded-folders-list"
    });
    for (const folder of this.excludedFolders) {
      const item = excludedList.createEl("div", {
        cls: "excluded-folder-item"
      });
      item.style.display = "flex";
      item.style.alignItems = "center";
      item.style.justifyContent = "space-between";
      item.style.padding = "6px 8px";
      item.style.margin = "3px 0";
      item.style.backgroundColor = "var(--background-primary)";
      item.style.borderRadius = "4px";
      item.style.border = "1px solid var(--background-modifier-border)";
      const pathContainer = item.createDiv({
        cls: "excluded-folder-path"
      });
      pathContainer.style.display = "flex";
      pathContainer.style.alignItems = "center";
      pathContainer.style.overflow = "hidden";
      pathContainer.style.flex = "1";
      const isFolder = folder.endsWith("/");
      const iconEl = pathContainer.createSpan({
        cls: `excluded-item-icon ${isFolder ? "folder-icon" : folder.includes("*") ? "search-icon" : "file-icon"}`
      });
      iconEl.style.marginRight = "8px";
      const textEl = pathContainer.createSpan({
        text: folder,
        cls: "excluded-folder-text"
      });
      textEl.style.overflow = "hidden";
      textEl.style.textOverflow = "ellipsis";
      textEl.style.whiteSpace = "nowrap";
      const removeButton = item.createEl("button", {
        cls: "excluded-folder-remove",
        text: "\xD7"
      });
      removeButton.style.border = "none";
      removeButton.style.background = "none";
      removeButton.style.cursor = "pointer";
      removeButton.style.color = "var(--text-muted)";
      removeButton.style.fontSize = "18px";
      removeButton.style.padding = "0 4px";
      removeButton.style.marginLeft = "4px";
      removeButton.addEventListener("mouseenter", () => {
        removeButton.style.color = "var(--text-error)";
      });
      removeButton.addEventListener("mouseleave", () => {
        removeButton.style.color = "var(--text-muted)";
      });
      removeButton.addEventListener("click", (e) => {
        e.stopPropagation();
        const index = this.excludedFolders.indexOf(folder);
        if (index !== -1) {
          this.excludedFolders.splice(index, 1);
          this.renderExcludedList(container);
        }
      });
    }
  }
  onClose() {
    document.removeEventListener("click", this.documentClickListener);
    this.contentEl.empty();
  }
};

// src/ui/settings/TaggingSettingsSection.ts
var TaggingSettingsSection = class extends BaseSettingSection {
  tagSourceSetting = null;
  predefinedTagsFileSetting = null;
  // Update settings visibility
  updateVisibility() {
    if (this.tagSourceSetting) {
      const shouldShowTagSource = this.plugin.settings.taggingMode !== "generate" /* GenerateNew */;
      this.tagSourceSetting.settingEl.style.display = shouldShowTagSource ? "flex" : "none";
    }
    if (this.predefinedTagsFileSetting) {
      const shouldShowTagsFile = this.plugin.settings.taggingMode !== "generate" /* GenerateNew */ && this.plugin.settings.tagSourceType === "file";
      this.predefinedTagsFileSetting.settingEl.style.display = shouldShowTagsFile ? "flex" : "none";
    }
  }
  display() {
    this.containerEl.createEl("h1", { text: "Tagging settings" });
    new import_obsidian9.Setting(this.containerEl).setName("Tagging mode").setDesc("Choose how tags should be generated").addDropdown((dropdown) => dropdown.addOptions({
      ["predefined" /* PredefinedTags */]: "Use predefined tags only",
      ["generate" /* GenerateNew */]: "Generate new tags",
      ["hybrid" /* Hybrid */]: "Hybrid mode (Generate + Predefined)"
    }).setValue(this.plugin.settings.taggingMode).onChange(async (value) => {
      this.plugin.settings.taggingMode = value;
      await this.plugin.saveSettings();
      this.updateVisibility();
    }));
    this.tagSourceSetting = new import_obsidian9.Setting(this.containerEl).setName("Tag source").setDesc("Choose where to get the predefined tags from").addDropdown((dropdown) => dropdown.addOptions({
      "file": "From predefined tags file",
      "vault": "From all existing tags in vault"
    }).setValue(this.plugin.settings.tagSourceType).onChange(async (value) => {
      this.plugin.settings.tagSourceType = value;
      await this.plugin.saveSettings();
      this.updateVisibility();
    }));
    this.predefinedTagsFileSetting = new import_obsidian9.Setting(this.containerEl).setName("Predefined tags file").setDesc("Path to a file containing predefined tags (one tag per line)");
    const tagsFileInputContainer = this.predefinedTagsFileSetting.controlEl.createDiv("path-input-container");
    const tagsFileInput = tagsFileInputContainer.createEl("input", {
      type: "text",
      placeholder: "path/to/your/tags.txt",
      cls: "path-input",
      value: this.plugin.settings.predefinedTagsPath || ""
    });
    const tagsDropdownContainer = tagsFileInputContainer.createDiv("path-dropdown-container");
    tagsDropdownContainer.style.display = "none";
    const updateTagsDropdown = async (searchTerm) => {
      try {
        const items = [];
        const lowerSearchTerm = searchTerm.toLowerCase().trim();
        if (!lowerSearchTerm) {
          const commonTagFiles = ["tags.md", "tags.txt", "Tags/", "tag_list.md"];
          this.plugin.app.vault.getFiles().forEach((file) => {
            if (commonTagFiles.some((tagFile) => file.path.toLowerCase().includes(tagFile.toLowerCase()))) {
              items.push({
                path: file.path,
                isFolder: false,
                name: file.name
              });
            }
          });
        } else {
          this.plugin.app.vault.getFiles().forEach((file) => {
            const filePath = file.path.toLowerCase();
            const fileName = file.name.toLowerCase();
            if (filePath.includes(lowerSearchTerm) || fileName.includes(lowerSearchTerm)) {
              items.push({
                path: file.path,
                isFolder: false,
                name: file.name
              });
            }
          });
          this.plugin.app.vault.getAllLoadedFiles().forEach((abstractFile) => {
            if ("children" in abstractFile) {
              const folderPath = abstractFile.path.toLowerCase() + "/";
              if (folderPath.includes(lowerSearchTerm)) {
                items.push({
                  path: abstractFile.path + "/",
                  isFolder: true,
                  name: abstractFile.name
                });
              }
            }
          });
        }
        items.sort((a, b) => {
          const aStartsWith = a.name.toLowerCase().startsWith(lowerSearchTerm);
          const bStartsWith = b.name.toLowerCase().startsWith(lowerSearchTerm);
          if (aStartsWith && !bStartsWith)
            return -1;
          if (!aStartsWith && bStartsWith)
            return 1;
          if (a.isFolder && !b.isFolder)
            return -1;
          if (!a.isFolder && b.isFolder)
            return 1;
          return a.path.localeCompare(b.path);
        });
        const limitedItems = items.slice(0, 15);
        tagsDropdownContainer.empty();
        if (limitedItems.length === 0) {
          tagsDropdownContainer.createEl("div", {
            text: "No matching files",
            cls: "path-dropdown-empty"
          });
          return;
        }
        tagsDropdownContainer.style.position = "absolute";
        tagsDropdownContainer.style.width = "100%";
        tagsDropdownContainer.style.zIndex = "1000";
        tagsDropdownContainer.style.backgroundColor = "var(--background-primary)";
        tagsDropdownContainer.style.border = "1px solid var(--background-modifier-border)";
        tagsDropdownContainer.style.maxHeight = "200px";
        tagsDropdownContainer.style.overflowY = "auto";
        tagsDropdownContainer.style.top = "100%";
        tagsDropdownContainer.style.left = "0";
        tagsDropdownContainer.style.borderRadius = "4px";
        tagsDropdownContainer.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.2)";
        limitedItems.forEach((item) => {
          const pathItem = tagsDropdownContainer.createEl("div", {
            cls: "path-dropdown-item"
          });
          pathItem.style.padding = "6px 8px";
          pathItem.style.cursor = "pointer";
          pathItem.style.borderBottom = "1px solid var(--background-modifier-border-hover)";
          pathItem.style.display = "flex";
          pathItem.style.alignItems = "center";
          pathItem.addEventListener("mouseenter", () => {
            pathItem.style.backgroundColor = "var(--background-secondary)";
          });
          pathItem.addEventListener("mouseleave", () => {
            pathItem.style.backgroundColor = "";
          });
          const iconEl = pathItem.createSpan({
            cls: `path-item-icon ${item.isFolder ? "folder-icon" : "file-icon"}`
          });
          iconEl.style.marginRight = "6px";
          iconEl.style.fontSize = "14px";
          const textEl = pathItem.createSpan({
            cls: "path-item-text"
          });
          if (lowerSearchTerm && item.path.toLowerCase().includes(lowerSearchTerm)) {
            const path2 = item.path;
            const lowerPath = path2.toLowerCase();
            const index = lowerPath.indexOf(lowerSearchTerm);
            if (index >= 0) {
              if (index > 0) {
                textEl.createSpan({
                  text: path2.substring(0, index)
                });
              }
              textEl.createSpan({
                text: path2.substring(index, index + lowerSearchTerm.length),
                cls: "path-match-highlight"
              }).style.backgroundColor = "var(--text-highlight-bg)";
              if (index + lowerSearchTerm.length < path2.length) {
                textEl.createSpan({
                  text: path2.substring(index + lowerSearchTerm.length)
                });
              }
            } else {
              textEl.setText(path2);
            }
          } else {
            textEl.setText(item.path);
          }
          pathItem.addEventListener("click", async () => {
            tagsFileInput.value = item.path;
            this.plugin.settings.predefinedTagsPath = item.path;
            await this.plugin.saveSettings();
            tagsDropdownContainer.style.display = "none";
          });
        });
      } catch (error) {
        tagsDropdownContainer.empty();
        tagsDropdownContainer.createEl("div", {
          text: "Error loading files",
          cls: "path-dropdown-error"
        });
      }
    };
    tagsFileInput.addEventListener("focus", () => {
      tagsDropdownContainer.style.display = "block";
      updateTagsDropdown(tagsFileInput.value);
    });
    tagsFileInput.addEventListener("click", (e) => {
      e.stopPropagation();
      tagsDropdownContainer.style.display = "block";
      updateTagsDropdown(tagsFileInput.value);
    });
    tagsFileInput.addEventListener("input", async () => {
      this.plugin.settings.predefinedTagsPath = tagsFileInput.value;
      await this.plugin.saveSettings();
      tagsDropdownContainer.style.display = "block";
      updateTagsDropdown(tagsFileInput.value);
    });
    const documentClickListener = (event) => {
      if (!tagsFileInputContainer.contains(event.target)) {
        tagsDropdownContainer.style.display = "none";
      }
    };
    document.addEventListener("click", documentClickListener);
    this.plugin.register(() => {
      document.removeEventListener("click", documentClickListener);
    });
    this.updateVisibility();
    this.containerEl.createEl("h3", { text: "File exclusion" });
    const excludedFoldersSetting = new import_obsidian9.Setting(this.containerEl).setName("Excluded files and folders").setDesc("Files matching these patterns will be hidden in Search, Graph View, and Unlinked Mentions, less noticeable in Quick Switcher and link suggestions.");
    const excludedInfo = excludedFoldersSetting.descEl.createDiv({
      cls: "excluded-info"
    });
    const updateExcludedInfo = () => {
      excludedInfo.empty();
      if (this.plugin.settings.excludedFolders.length === 0) {
        excludedInfo.createSpan({
          text: "No exclusions configured",
          cls: "excluded-info-text muted"
        });
      } else {
        excludedInfo.createSpan({
          text: `${this.plugin.settings.excludedFolders.length} pattern${this.plugin.settings.excludedFolders.length === 1 ? "" : "s"} configured`,
          cls: "excluded-info-text"
        });
      }
    };
    updateExcludedInfo();
    excludedFoldersSetting.addButton(
      (button) => button.setButtonText("Manage").setCta().onClick(() => {
        const modal = new ExcludedFilesModal(
          this.plugin.app,
          this.plugin,
          async (excludedFolders) => {
            this.plugin.settings.excludedFolders = excludedFolders;
            await this.plugin.saveSettings();
            updateExcludedInfo();
          }
        );
        modal.open();
      })
    );
    this.containerEl.createEl("h3", { text: "Tag range settings" });
    new import_obsidian9.Setting(this.containerEl).setName("Maximum predefined tags").setDesc("Maximum number of predefined tags to use (0-10). Used in Predefined and Hybrid modes.").addSlider((slider) => {
      const container = slider.sliderEl.parentElement;
      if (container) {
        const numberDisplay = container.createSpan({ cls: "value-display" });
        numberDisplay.style.marginLeft = "10px";
        numberDisplay.setText(String(this.plugin.settings.tagRangePredefinedMax));
        slider.setLimits(0, 10, 1).setValue(this.plugin.settings.tagRangePredefinedMax).setDynamicTooltip().onChange(async (value) => {
          numberDisplay.setText(String(value));
          this.plugin.settings.tagRangePredefinedMax = value;
          await this.plugin.saveSettings();
        });
      }
      return slider;
    });
    new import_obsidian9.Setting(this.containerEl).setName("Maximum generated tags").setDesc("Maximum number of new tags to generate (0-10). Used in Generate and Hybrid modes.").addSlider((slider) => {
      const container = slider.sliderEl.parentElement;
      if (container) {
        const numberDisplay = container.createSpan({ cls: "value-display" });
        numberDisplay.style.marginLeft = "10px";
        numberDisplay.setText(String(this.plugin.settings.tagRangeGenerateMax));
        slider.setLimits(0, 10, 1).setValue(this.plugin.settings.tagRangeGenerateMax).setDynamicTooltip().onChange(async (value) => {
          numberDisplay.setText(String(value));
          this.plugin.settings.tagRangeGenerateMax = value;
          await this.plugin.saveSettings();
        });
      }
      return slider;
    });
    new import_obsidian9.Setting(this.containerEl).setName("Output language").setDesc("Language for generating tags").addDropdown((dropdown) => {
      const options = LanguageUtils.getLanguageOptions();
      return dropdown.addOptions(options).setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/ui/settings/SupportSection.ts
var import_obsidian10 = require("obsidian");
var SupportSection = class extends BaseSettingSection {
  display() {
    this.containerEl.createEl("h1", { text: "Support developer" });
    const supportEl = this.containerEl.createDiv({ cls: "support-container" });
    supportEl.createSpan({ text: "If you find this plugin helpful, consider buying me a coffee \u2615\uFE0F" });
    new import_obsidian10.ButtonComponent(supportEl).setButtonText("Buy me a coffee").setClass("support-button").onClick(() => {
      window.open("https://buymeacoffee.com/niehu2015o", "_blank");
    });
  }
};

// src/ui/settings/AITaggerSettingTab.ts
var AITaggerSettingTab = class extends import_obsidian11.PluginSettingTab {
  plugin;
  llmSection;
  taggingSection;
  supportSection;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.llmSection = new LLMSettingsSection(this.plugin, containerEl, this);
    this.taggingSection = new TaggingSettingsSection(this.plugin, containerEl, this);
    this.supportSection = new SupportSection(this.plugin, containerEl, this);
    this.llmSection.display();
    this.taggingSection.display();
    this.supportSection.display();
  }
};

// src/utils/eventHandlers.ts
var import_obsidian12 = require("obsidian");
var EventHandlers = class {
  app;
  fileChangeTimeoutId = null;
  constructor(app) {
    this.app = app;
  }
  registerEventHandlers() {
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian12.TFile && file.extension === "md") {
        this.app.workspace.trigger("file-open", file);
      }
    });
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian12.TFile && file.extension === "md") {
        if (this.fileChangeTimeoutId) {
          clearTimeout(this.fileChangeTimeoutId);
        }
        this.fileChangeTimeoutId = setTimeout(() => {
          this.app.workspace.trigger("file-open", file);
          this.fileChangeTimeoutId = null;
        }, 2e3);
      }
    });
    this.app.workspace.on("layout-change", () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
      if (view?.getMode() === "source") {
        view.editor.refresh();
      }
    });
  }
  cleanup() {
    if (this.fileChangeTimeoutId) {
      clearTimeout(this.fileChangeTimeoutId);
      this.fileChangeTimeoutId = null;
    }
  }
};

// src/utils/tagNetworkUtils.ts
var TagNetworkManager = class {
  app;
  tagData = /* @__PURE__ */ new Map();
  constructor(app) {
    this.app = app;
  }
  async buildTagNetwork() {
    this.tagData.clear();
    const allFiles = this.app.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache?.frontmatter?.tags) {
        const tags = TagUtils.getExistingTags(cache.frontmatter);
        for (const tag of tags) {
          if (!this.tagData.has(tag)) {
            this.tagData.set(tag, {
              tag,
              frequency: 0,
              connections: /* @__PURE__ */ new Map()
            });
          }
          const tagInfo = this.tagData.get(tag);
          tagInfo.frequency += 1;
        }
        for (let i = 0; i < tags.length; i++) {
          for (let j = i + 1; j < tags.length; j++) {
            const tag1 = tags[i];
            const tag2 = tags[j];
            const tagInfo1 = this.tagData.get(tag1);
            if (!tagInfo1.connections.has(tag2)) {
              tagInfo1.connections.set(tag2, 0);
            }
            tagInfo1.connections.set(tag2, tagInfo1.connections.get(tag2) + 1);
            const tagInfo2 = this.tagData.get(tag2);
            if (!tagInfo2.connections.has(tag1)) {
              tagInfo2.connections.set(tag1, 0);
            }
            tagInfo2.connections.set(tag1, tagInfo2.connections.get(tag1) + 1);
          }
        }
      }
    }
    return this.tagData;
  }
  getNetworkData() {
    const nodes = [];
    const edges = [];
    const edgeSet = /* @__PURE__ */ new Set();
    this.tagData.forEach((data) => {
      nodes.push({
        id: data.tag,
        label: data.tag.startsWith("#") ? data.tag.substring(1) : data.tag,
        size: Math.max(5, Math.min(30, 5 + data.frequency * 3)),
        frequency: data.frequency
      });
      data.connections.forEach((weight, connectedTag) => {
        const edgeId = [data.tag, connectedTag].sort().join("-");
        if (!edgeSet.has(edgeId)) {
          edges.push({
            id: edgeId,
            source: data.tag,
            target: connectedTag,
            weight
          });
          edgeSet.add(edgeId);
        }
      });
    });
    return { nodes, edges };
  }
};

// src/ui/views/TagNetworkView.ts
var import_obsidian13 = require("obsidian");
var TAG_NETWORK_VIEW_TYPE = "tag-network-view";
var TagNetworkView = class extends import_obsidian13.ItemView {
  constructor(leaf, data) {
    super(leaf);
    this.data = data;
    this.networkData = data;
  }
  networkData;
  cleanup = [];
  d3LoadPromise = null;
  getViewType() {
    return TAG_NETWORK_VIEW_TYPE;
  }
  getDisplayText() {
    return "Tag Network";
  }
  getIcon() {
    return "graph";
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("tag-network-view");
    contentEl.createEl("h2", { text: "Tag Network Visualization" });
    contentEl.createEl("p", {
      text: "Node size represents tag frequency. Connections represent tags that appear together in notes."
    });
    const controlsContainer = contentEl.createDiv({ cls: "tag-network-controls" });
    const searchContainer = controlsContainer.createDiv({ cls: "tag-network-search" });
    searchContainer.createEl("span", { text: "Search tags: " });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Type to search...",
      cls: "tag-network-search-input"
    });
    const legendContainer = contentEl.createDiv({ cls: "tag-network-legend" });
    legendContainer.createEl("span", { text: "Frequency: " });
    const lowFreqItem = legendContainer.createDiv({ cls: "tag-network-legend-item" });
    lowFreqItem.createDiv({ cls: "tag-network-legend-color low" });
    lowFreqItem.createEl("span", { text: "Low" });
    const mediumFreqItem = legendContainer.createDiv({ cls: "tag-network-legend-item" });
    mediumFreqItem.createDiv({ cls: "tag-network-legend-color medium" });
    mediumFreqItem.createEl("span", { text: "Medium" });
    const highFreqItem = legendContainer.createDiv({ cls: "tag-network-legend-item" });
    highFreqItem.createDiv({ cls: "tag-network-legend-color high" });
    highFreqItem.createEl("span", { text: "High" });
    const container = contentEl.createDiv({ cls: "tag-network-container" });
    const tooltip = contentEl.createDiv({ cls: "tag-tooltip" });
    tooltip.addClass("tag-tooltip-hidden");
    tooltip.createDiv({ cls: "tag-tooltip-content" });
    const statusEl = contentEl.createDiv({ cls: "tag-network-status" });
    statusEl.setText("Loading visualization...");
    if (this.networkData.nodes.length === 0) {
      statusEl.setText("No tags found in your vault. Add some tags first!");
      return;
    }
    try {
      await this.loadVisualizationLibrary(container, searchInput, tooltip, statusEl);
    } catch (error) {
      statusEl.setText("Error loading visualization. Please try again.");
    }
  }
  async onClose() {
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup = [];
    const d3Script = document.querySelector('script[src*="d3.v7.min.js"]');
    if (d3Script) {
      d3Script.remove();
    }
    this.contentEl.empty();
  }
  async onResize() {
    const container = this.contentEl.querySelector(".tag-network-container");
    const searchInput = this.contentEl.querySelector(".tag-network-search-input");
    const tooltip = this.contentEl.querySelector(".tag-tooltip");
    const statusEl = this.contentEl.querySelector(".tag-network-status");
    if (container && searchInput && tooltip && statusEl) {
      try {
        await this.loadVisualizationLibrary(container, searchInput, tooltip, statusEl);
      } catch (error) {
      }
    }
  }
  async loadVisualizationLibrary(container, searchInput, tooltip, statusEl) {
    if (this.d3LoadPromise) {
      await this.d3LoadPromise;
      return;
    }
    if (window.d3) {
      this.renderD3Network(container, searchInput, tooltip, statusEl);
      return;
    }
    this.d3LoadPromise = new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = "https://d3js.org/d3.v7.min.js";
      script.async = true;
      const cleanup = () => {
        script.removeEventListener("load", handleLoad);
        script.removeEventListener("error", handleError);
      };
      const handleLoad = () => {
        cleanup();
        try {
          this.renderD3Network(container, searchInput, tooltip, statusEl);
          resolve();
        } catch (error) {
          statusEl.setText("Error rendering network. Please try again.");
          reject(error);
        }
      };
      const handleError = (error) => {
        cleanup();
        statusEl.setText("Failed to load visualization library. Please check your internet connection.");
        reject(error);
      };
      script.addEventListener("load", handleLoad);
      script.addEventListener("error", handleError);
      document.head.appendChild(script);
      this.cleanup.push(() => {
        cleanup();
        script.remove();
      });
    });
    try {
      await this.d3LoadPromise;
    } finally {
      this.d3LoadPromise = null;
    }
  }
  renderD3Network(container, searchInput, tooltip, statusEl) {
    const d3 = window.d3;
    if (!d3) {
      statusEl.setText("Error: D3.js library not loaded");
      return;
    }
    statusEl.setText("Rendering network...");
    container.empty();
    const width = container.clientWidth || 800;
    const height = container.clientHeight || 600;
    const svg = d3.select(container).append("svg").attr("width", width).attr("height", height).attr("viewBox", [0, 0, width, height]).attr("class", "tag-network-svg");
    const g = svg.append("g");
    const zoom = d3.zoom().scaleExtent([0.1, 8]).on("zoom", (event) => {
      g.attr("transform", event.transform);
    });
    svg.call(zoom);
    const nodes = this.networkData.nodes.map((node2) => ({
      ...node2,
      x: void 0,
      y: void 0,
      fx: void 0,
      fy: void 0
    }));
    const links = this.networkData.edges.map((edge) => ({
      source: edge.source,
      target: edge.target,
      weight: edge.weight
    }));
    const simulation = d3.forceSimulation(nodes).force("link", d3.forceLink(links).id((d) => d.id).distance(100)).force("charge", d3.forceManyBody().strength(-300)).force("center", d3.forceCenter(width / 2, height / 2)).force("collision", d3.forceCollide().radius((d) => d.size + 5));
    const link = g.append("g").attr("class", "tag-network-link").selectAll("line").data(links).join("line").attr("stroke-width", (d) => Math.sqrt(d.weight));
    const node = g.append("g").selectAll("circle").data(nodes).join("circle").attr("class", "tag-network-node").attr("r", (d) => d.size).attr("fill", (d) => this.getNodeColor(d.frequency)).call(this.drag(simulation));
    const labels = g.append("g").selectAll("text").data(nodes).join("text").attr("class", "tag-network-label").text((d) => d.label).attr("dx", (d) => d.size + 5).attr("dy", 4);
    const handleMouseOver = (event, d) => {
      node.attr("opacity", (n) => {
        const isConnected = links.some(
          (link2) => link2.source.id === d.id && link2.target.id === n.id || link2.target.id === d.id && link2.source.id === n.id
        );
        return n === d || isConnected ? 1 : 0.2;
      });
      link.attr(
        "stroke-opacity",
        (l) => l.source.id === d.id || l.target.id === d.id ? 1 : 0.1
      );
      tooltip.addClass("visible");
      tooltip.style.left = `${event.pageX + 5}px`;
      tooltip.style.top = `${event.pageY + 5}px`;
      const tooltipContent = tooltip.querySelector(".tag-tooltip-content");
      if (tooltipContent) {
        const connectedNodes = links.filter(
          (link2) => link2.source.id === d.id || link2.target.id === d.id
        ).length;
        tooltipContent.innerHTML = `
                    <div class="tag-tooltip-title">${d.label}</div>
                    <div class="tag-tooltip-info">Frequency: ${d.frequency}</div>
                    <div class="tag-tooltip-info">Connected to ${connectedNodes} other tags</div>
                `;
      }
    };
    const handleMouseOut = () => {
      node.attr("opacity", 1);
      link.attr("stroke-opacity", 0.6);
      tooltip.removeClass("visible");
    };
    node.on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
    const handleSearch = () => {
      const searchTerm = searchInput.value.toLowerCase();
      if (searchTerm.length > 0) {
        node.attr(
          "opacity",
          (d) => d.label.toLowerCase().includes(searchTerm) ? 1 : 0.2
        );
        link.attr("stroke-opacity", (l) => {
          const sourceMatches = l.source.label.toLowerCase().includes(searchTerm);
          const targetMatches = l.target.label.toLowerCase().includes(searchTerm);
          return sourceMatches && targetMatches ? 1 : 0.1;
        });
      } else {
        node.attr("opacity", 1);
        link.attr("stroke-opacity", 0.6);
      }
    };
    searchInput.addEventListener("input", handleSearch);
    this.cleanup.push(() => searchInput.removeEventListener("input", handleSearch));
    simulation.on("tick", () => {
      link.attr("x1", (d) => d.source.x).attr("y1", (d) => d.source.y).attr("x2", (d) => d.target.x).attr("y2", (d) => d.target.y);
      node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
      labels.attr("x", (d) => d.x).attr("y", (d) => d.y);
    });
    this.cleanup.push(() => simulation.stop());
    statusEl.style.display = "none";
  }
  drag(simulation) {
    const d3 = window.d3;
    function dragstarted(event) {
      if (!event.active)
        simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }
    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }
    function dragended(event) {
      if (!event.active)
        simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
    return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
  }
  getNodeColor(frequency, opacity = 1) {
    const minFreq = 1;
    const maxFreq = Math.max(...this.networkData.nodes.map((n) => n.frequency));
    const normalizedFreq = (frequency - minFreq) / (maxFreq - minFreq);
    const r = Math.floor(100 - normalizedFreq * 100);
    const g = Math.floor(149 - normalizedFreq * 100);
    const b = Math.floor(237 - normalizedFreq * 50);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  }
};

// src/utils/batchProcessor.ts
var import_obsidian14 = require("obsidian");
var BatchProcessor = class {
  options;
  isCancelled = false;
  constructor(options = {}) {
    this.options = {
      batchSize: 10,
      progressUpdateInterval: 5e3,
      silent: false,
      ...options
    };
  }
  cancel() {
    this.isCancelled = true;
  }
  async processBatch(files, processor) {
    const totalFiles = files.length;
    let processedCount = 0;
    let successCount = 0;
    let lastNoticeTime = Date.now();
    const errors = [];
    const batches = [];
    for (let i = 0; i < files.length; i += this.options.batchSize) {
      batches.push(files.slice(i, i + this.options.batchSize));
    }
    for (const batch of batches) {
      if (this.isCancelled) {
        break;
      }
      try {
        const batchResults = await Promise.all(
          batch.map(async (file) => {
            try {
              await processor(file);
              return true;
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : "Unknown error";
              errors.push({ file: file.path, error: errorMessage });
              return false;
            }
          })
        );
        const batchSuccesses = batchResults.filter(Boolean).length;
        successCount += batchSuccesses;
        processedCount += batch.length;
        const currentTime = Date.now();
        if (!this.options.silent && (currentTime - lastNoticeTime >= this.options.progressUpdateInterval || processedCount === totalFiles)) {
          new import_obsidian14.Notice(`${Math.round(processedCount / totalFiles * 100)}%`);
          lastNoticeTime = currentTime;
        }
      } catch (error) {
      }
    }
    if (!this.options.silent && successCount > 0) {
      new import_obsidian14.Notice(`Cleared ${successCount} notes`);
    }
    return {
      success: errors.length === 0,
      processed: processedCount,
      successCount,
      errors
    };
  }
};

// src/utils/tagOperations.ts
var TagOperations = class {
  app;
  batchProcessor;
  constructor(app) {
    this.app = app;
    this.batchProcessor = new BatchProcessor();
  }
  /**
   * Clear tags from a single note
   */
  async clearNoteTags(file) {
    try {
      const result = await TagUtils.clearTags(this.app, file);
      if (result.success && result.message !== "Skipped: Note has no frontmatter") {
        this.app.vault.trigger("modify", file);
      }
      return result;
    } catch (error) {
      return {
        success: false,
        message: `Failed to clear tags: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Clear tags from all notes in a directory
   */
  async clearDirectoryTags(directory) {
    if (directory.length === 0) {
      return {
        success: true,
        processed: 0,
        successCount: 0,
        errors: []
      };
    }
    const result = await this.batchProcessor.processBatch(
      directory,
      async (file) => {
        const result2 = await this.clearNoteTags(file);
        if (!result2.success && result2.message !== "Skipped: Note has no frontmatter") {
          return { success: false, message: result2.message };
        }
      }
    );
    this.app.workspace.trigger("layout-change");
    return result;
  }
  /**
   * Clear tags from all notes in the vault
   */
  async clearVaultTags() {
    const files = this.app.vault.getMarkdownFiles();
    return this.clearDirectoryTags(files);
  }
  /**
   * Cancel any ongoing batch operations
   */
  cancelOperations() {
    this.batchProcessor.cancel();
  }
  /**
   * Refresh metadata cache for multiple files
   */
  async refreshMetadataCache(files) {
    files.forEach((file) => {
      this.app.metadataCache.trigger("changed", file);
    });
    this.app.workspace.trigger("layout-change");
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
};

// src/main.ts
var AITaggerPlugin = class extends import_obsidian15.Plugin {
  settings = { ...DEFAULT_SETTINGS };
  llmService;
  eventHandlers;
  tagNetworkManager;
  tagOperations;
  constructor(app, manifest) {
    super(app, manifest);
    this.llmService = new LocalLLMService({
      endpoint: DEFAULT_SETTINGS.localEndpoint,
      modelName: DEFAULT_SETTINGS.localModel,
      language: DEFAULT_SETTINGS.language
    }, app);
    this.eventHandlers = new EventHandlers(app);
    this.tagNetworkManager = new TagNetworkManager(app);
    this.tagOperations = new TagOperations(app);
  }
  async loadSettings() {
    const oldSettings = await this.loadData();
    if (oldSettings?.serviceType === "ollama") {
      oldSettings.serviceType = "local";
      oldSettings.localEndpoint = oldSettings.ollamaEndpoint;
      oldSettings.localModel = oldSettings.ollamaModel;
      delete oldSettings.ollamaEndpoint;
      delete oldSettings.ollamaModel;
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, oldSettings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.initializeLLMService();
  }
  async initializeLLMService() {
    await this.llmService?.dispose();
    this.llmService = this.settings.serviceType === "local" ? new LocalLLMService({
      endpoint: this.settings.localEndpoint,
      modelName: this.settings.localModel,
      language: this.settings.language
    }, this.app) : new CloudLLMService({
      endpoint: this.settings.cloudEndpoint,
      apiKey: this.settings.cloudApiKey,
      modelName: this.settings.cloudModel,
      type: this.settings.cloudServiceType,
      language: this.settings.language
    }, this.app);
  }
  async onload() {
    await this.loadSettings();
    await this.initializeLLMService();
    this.eventHandlers.registerEventHandlers();
    this.addSettingTab(new AITaggerSettingTab(this.app, this));
    registerCommands(this);
    this.registerView(
      TAG_NETWORK_VIEW_TYPE,
      (leaf) => new TagNetworkView(leaf, this.tagNetworkManager.getNetworkData())
    );
    this.addRibbonIcon(
      "tags",
      "Analyze and tag current note",
      (evt) => {
        this.analyzeAndTagCurrentNote();
      }
    );
    this.addRibbonIcon(
      "graph",
      "View tag relationships network",
      (evt) => {
        this.showTagNetwork();
      }
    );
  }
  async onunload() {
    await this.llmService?.dispose();
    this.eventHandlers.cleanup();
    this.app.workspace.detachLeavesOfType(TAG_NETWORK_VIEW_TYPE);
    this.app.workspace.trigger("layout-change");
  }
  async showTagNetwork() {
    try {
      const statusNotice = new import_obsidian15.Notice("Building tag network...", 0);
      await this.tagNetworkManager.buildTagNetwork();
      const networkData = this.tagNetworkManager.getNetworkData();
      statusNotice.hide();
      if (!networkData.nodes.length) {
        new import_obsidian15.Notice("No tags were found in your vault", 3e3);
        return;
      }
      if (!networkData.edges.length) {
        new import_obsidian15.Notice("Tags were found, but there are no connections between them", 4e3);
      }
      let leaf = this.app.workspace.getLeavesOfType(TAG_NETWORK_VIEW_TYPE)[0];
      if (!leaf) {
        const newLeaf = await this.app.workspace.getRightLeaf(false);
        if (!newLeaf) {
          throw new Error("Failed to create new workspace leaf");
        }
        await newLeaf.setViewState({
          type: TAG_NETWORK_VIEW_TYPE,
          active: true
        });
        leaf = this.app.workspace.getLeavesOfType(TAG_NETWORK_VIEW_TYPE)[0];
        if (!leaf) {
          throw new Error("Failed to initialize tag network view");
        }
      }
      this.app.workspace.revealLeaf(leaf);
    } catch (error) {
      new import_obsidian15.Notice("Failed to build tag network. Please check console for details.", 4e3);
    }
  }
  /**
   * Test connection to the configured LLM service
   */
  async testConnection() {
    return await this.llmService.testConnection();
  }
  async showConfirmationDialog(message) {
    return new Promise((resolve) => {
      const modal = new ConfirmationModal(
        this.app,
        "Warning",
        message,
        () => resolve(true)
      );
      modal.onClose = () => resolve(false);
      modal.open();
    });
  }
  /**
   * Get all markdown files in the vault, excluding those that match exclusion patterns
   */
  getNonExcludedMarkdownFiles() {
    const allFiles = this.app.vault.getMarkdownFiles();
    return allFiles.filter((file) => !TagUtils.isFileExcluded(file, this.settings.excludedFolders));
  }
  async clearAllNotesTags() {
    const files = this.getNonExcludedMarkdownFiles();
    if (await this.showConfirmationDialog(
      `Remove all tags from ${files.length} notes? This action cannot be undone.`
    )) {
      try {
        await this.tagOperations.clearVaultTags();
        new import_obsidian15.Notice("Successfully cleared all tags from vault", 3e3);
      } catch (error) {
        new import_obsidian15.Notice("Failed to clear tags from vault", 4e3);
      }
    }
  }
  async clearNoteTags() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian15.Notice("Please open a note before clearing tags", 3e3);
      return;
    }
    const result = await this.tagOperations.clearNoteTags(activeFile);
    this.handleTagUpdateResult(result);
  }
  async clearDirectoryTags(directory) {
    return this.tagOperations.clearDirectoryTags(directory);
  }
  handleTagUpdateResult(result, silent = false) {
    if (!result) {
      !silent && new import_obsidian15.Notice("Failed to update tags: No result returned", 3e3);
      return;
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
    if (result.success) {
      if (view?.getMode() === "source") {
        view.editor.refresh();
      }
      this.app.workspace.trigger("layout-change");
      !silent && new import_obsidian15.Notice(result.message, 3e3);
    } else {
      !silent && new import_obsidian15.Notice(`Failed to update tags: ${result.message || "Unknown error"}`, 4e3);
    }
  }
  async analyzeAndTagFiles(files) {
    if (!files?.length)
      return;
    const statusNotice = new import_obsidian15.Notice(`Analyzing ${files.length} files...`, 0);
    try {
      let processed = 0, successful = 0;
      let lastNotice = Date.now();
      for (const file of files) {
        try {
          const content = await this.app.vault.read(file);
          if (!content.trim())
            continue;
          const result = await this.analyzeAndTagNote(file, content);
          result.success && successful++;
          this.handleTagUpdateResult(result, true);
          processed++;
          if (Date.now() - lastNotice >= 15e3) {
            new import_obsidian15.Notice(`Progress: ${processed}/${files.length} files processed`, 3e3);
            lastNotice = Date.now();
          }
        } catch (error) {
          new import_obsidian15.Notice(`Error processing ${file.path}`, 4e3);
        }
      }
      new import_obsidian15.Notice(`Successfully tagged ${successful} out of ${files.length} files`, 4e3);
    } catch (error) {
      new import_obsidian15.Notice("Failed to complete batch processing", 4e3);
    } finally {
      statusNotice.hide();
    }
  }
  calculateMaxTags() {
    switch (this.settings.taggingMode) {
      case "predefined" /* PredefinedTags */:
        return this.settings.tagRangePredefinedMax;
      case "hybrid" /* Hybrid */:
        return this.settings.tagRangePredefinedMax + this.settings.tagRangeGenerateMax;
      case "generate" /* GenerateNew */:
      default:
        return this.settings.tagRangeGenerateMax;
    }
  }
  /**
   * Analyzes and tags the currently open note
   * @returns Promise that resolves when the operation completes
   */
  async analyzeAndTagCurrentNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian15.Notice("Please open a note before analyzing", 3e3);
      return;
    }
    const content = await this.app.vault.read(activeFile);
    if (!content.trim()) {
      new import_obsidian15.Notice("Cannot analyze empty note", 3e3);
      return;
    }
    try {
      const result = await this.analyzeAndTagNote(activeFile, content);
      this.handleTagUpdateResult(result);
    } catch (error) {
      new import_obsidian15.Notice("Failed to analyze note. Please check console for details.", 4e3);
    }
  }
  /**
   * Analyzes content using hybrid mode and generates tags
   * @param content Content to analyze
   * @returns Array of tags
   */
  async analyzeWithHybridMode(content) {
    let predefinedTags = [];
    if (this.settings.tagSourceType === "file") {
      const fileTags = await TagUtils.getTagsFromFile(this.app, this.settings.predefinedTagsPath);
      if (fileTags) {
        predefinedTags = fileTags;
      }
    } else {
      predefinedTags = TagUtils.getAllTags(this.app);
    }
    const hybridResult = await this.llmService.analyzeTags(
      content,
      predefinedTags,
      "hybrid" /* Hybrid */,
      Math.max(this.settings.tagRangeGenerateMax, this.settings.tagRangePredefinedMax),
      // Use the larger max tag setting
      this.settings.language
    );
    const normalizedGeneratedTags = TagUtils.formatTags(hybridResult.suggestedTags || []);
    const normalizedMatchedTags = TagUtils.formatTags(hybridResult.matchedExistingTags || []);
    const allTags = TagUtils.mergeTags(normalizedGeneratedTags, normalizedMatchedTags);
    return { tags: allTags };
  }
  /**
   * Analyzes note content and applies tags
   * Supports receiving direct analysis results or analyzing based on content
   * @param file Target file
   * @param contentOrAnalysis File content or existing analysis result
   * @returns Tag operation result
   */
  async analyzeAndTagNote(file, contentOrAnalysis) {
    try {
      let analysis;
      if (typeof contentOrAnalysis === "string") {
        const content = contentOrAnalysis.trim();
        if (!content) {
          return {
            success: false,
            message: "Cannot analyze empty note"
          };
        }
        switch (this.settings.taggingMode) {
          case "generate" /* GenerateNew */:
            analysis = await this.llmService.analyzeTags(
              content,
              [],
              // Empty array, generate tags purely based on content
              "generate" /* GenerateNew */,
              this.settings.tagRangeGenerateMax,
              this.settings.language
            );
            break;
          case "predefined" /* PredefinedTags */:
            const predefinedTags = this.settings.tagSourceType === "file" ? await TagUtils.getTagsFromFile(this.app, this.settings.predefinedTagsPath) || [] : TagUtils.getAllTags(this.app);
            if (!predefinedTags.length) {
              return {
                success: false,
                message: "No predefined tags available"
              };
            }
            analysis = await this.llmService.analyzeTags(
              content,
              predefinedTags,
              "predefined" /* PredefinedTags */,
              this.settings.tagRangePredefinedMax
            );
            break;
          case "hybrid" /* Hybrid */:
            const hybridPredefinedTags = this.settings.tagSourceType === "file" ? await TagUtils.getTagsFromFile(this.app, this.settings.predefinedTagsPath) || [] : TagUtils.getAllTags(this.app);
            analysis = await this.llmService.analyzeTags(
              content,
              hybridPredefinedTags,
              "hybrid" /* Hybrid */,
              Math.max(this.settings.tagRangeGenerateMax, this.settings.tagRangePredefinedMax),
              this.settings.language
            );
            break;
          default:
            return {
              success: false,
              message: `Unsupported tagging mode: ${this.settings.taggingMode}`
            };
        }
      } else {
        analysis = contentOrAnalysis;
      }
      if (!analysis) {
        return {
          success: false,
          message: "No analysis results available"
        };
      }
      let allTags = [];
      if (this.settings.taggingMode === "predefined" /* PredefinedTags */) {
        allTags = analysis.matchedExistingTags || [];
      } else if (this.settings.taggingMode === "generate" /* GenerateNew */) {
        allTags = analysis.suggestedTags || [];
      } else {
        const suggestedTags = analysis.suggestedTags || [];
        const matchedTags = analysis.matchedExistingTags || [];
        allTags = [...suggestedTags, ...matchedTags];
      }
      if (allTags.length > 0) {
        return await TagUtils.updateNoteTags(
          this.app,
          file,
          allTags,
          [],
          // No matched tags since we've already combined them
          false,
          // Show notifications
          this.settings.replaceTags
          // Always use the setting value
        );
      }
      return {
        success: false,
        message: "No valid tags were found or generated"
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/

/* nosourcemap */